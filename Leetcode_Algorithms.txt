Day 001, 07/13/2020 Mon
Day 002, 07/14/2020 Tue
Day 003, 07/15/2020 Wed
Day 004, 07/16/2020 Thu
Day 005, 07/17/2020 Fri
Day 006, 07/18/2020 Sat
Day 007, 07/19/2020 Sun
Day 008, 07/20/2020 Mon
Day 009, 07/21/2020 Tue
Day 010, 07/22/2020 Wed
Day 011, 07/23/2020 Thu
Day 012, 07/24/2020 Fri
Day 013, 07/25/2020 Sat
Day 014, 07/26/2020 Sun
Day 015, 07/27/2020 Mon
Day 016, 07/28/2020 Tue
Day 017, 07/29/2020 Wed
Day 018, 07/30/2020 Thu
Day 019, 07/31/2020 Fri
Day 020, 08/01/2020 Sat
Day 021, 08/02/2020 Sun
Day 022, 08/03/2020 Mon
Day 023, 08/04/2020 Tue
Day 024, 08/05/2020 Wed
Day 025, 08/06/2020 Thu
Day 026, 08/07/2020 Fri
Day 027, 08/08/2020 Sat
Day 028, 08/09/2020 Sun
Day 029, 08/10/2020 Mon
Day 030, 08/11/2020 Tue
Day 031, 08/12/2020 Wed
Day 032, 08/13/2020 Thu
Day 033, 08/14/2020 Fri
Day 034, 08/15/2020 Sat
Day 035, 08/16/2020 Sun

Day 036, 08/17/2020 Mon

1385. Find the Distance Value Between Two Arrays

class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        '''
        Find the distance between arr1 and arr2.
        
            types: arr1 (List[int])
                   arr2 (List[int])   
                      d (int)
            rtype: int
        '''
        return sum([not any([abs(x - y) <= d for y in arr2]) for x in arr1])



0748. Shortest Completing Word

class Solution:
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        '''
        Find the minimum length word from a given dictionary words, 
        which has all the letters from the string licensePlate.
        
            types: licensePlate (str) 
                          words (List[str])
            rtype: str
        '''
        # Filter out non-alphabetics chars in licensePlate,
        # and convert all chars to lower case.
        licensePlate = list(licensePlate)
        licensePlate = [x.lower() for x in licensePlate if x.isalpha()]
        licensePlate = ''.join(licensePlate)
        
        # Convert all letters in words to lower case
        words = [x.lower() for x in words]
        
        # Use counter to find the first word such that licensePlate is a subset of it.
        # If it is, then check if current word has smaller length and res. If yes, then 
        # assign this word to res. Otherwise, continue.
        res = 'a'*1000
        from collections import Counter
        plate_cnt = Counter(licensePlate)
        for word in words:
            cnt = Counter(word)
            if len(cnt - plate_cnt) >= 0 and len(plate_cnt - cnt) == 0:
                if len(word) < len(res):
                    res = word
        return res



0949. Largest Time for Given Digits

class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        '''
        Find the largest 24 hour time that can be made. 
        If no valid time can be made, return an empty string.
        
            type : A (List[int])
            rtype: str
        '''
        # Initiate result, res
        res = ''
        
        # Loop A. For each loop, find the largest legal hour, and 
        # check if min will also will be legal.
        current_h = current_m = -1
        for i in range(4):
            for j in range(4):
                # Create largest legal hour using two different ele
                if i != j and current_h <= 10*A[i] + A[j] < 24:
                    # Check if the other two eles and create legal min.
                    # If yes, find the largest one.
                    minute = [A[x] for x in range(4) if x not in [i, j]]
                    minute = [10 * minute[0] + minute[1], 10 * minute[1] + minute[0]]
                    minute = [x for x in minute if x < 60]
                    
                    if minute:
                        if 10*A[i] + A[j] == current_h and current_m < max(minute):
                                current_m = max(minute)
                        elif 10*A[i] + A[j] > current_h:
                                current_h = 10*A[i] + A[j]
                                current_m = max(minute)
                            
        if current_h == -1 and current_m == -1:
            return ''
        # Add leading zero if either of current_h or current_m is < 10
        current_h = '0' + str(current_h) if current_h < 10 else str(current_h)
        current_m = '0' + str(current_m) if current_m < 10 else str(current_m)
        
        return current_h  + ":" + current_m


Day 037, 08/18/2020 Tue



Day 038, 08/19/2020 Wed

1317. Convert Integer to the Sum of Two No-Zero Integers

class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        '''
        Convert n to the sum of two integers without 0
        
            -type : n (int)
            -rtype: List[int]
        '''
        # Loop n from 1 to n//2.
        # If neither of x or n-x contains 0, then return [x, n-x] 
        for x in range(1, n//2+1):
            if '0' not in str(x) and '0' not in str(n-x):
                return [x, n-x]



0257. Binary Tree Paths

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:



1078. Occurrences After Bigram

class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        '''
        Find all words after occurences of first and second word
        
            -type : text (str)
            -type : first (str)
            -type : second (str)
            -rtype: List[str]
        '''
        # Spilt text to a list
        text = text.split(' ')
        
        # Loop text and find such a pattern
        i = 0
        l = len(text) - 2
        res = []
        while i < l:
            if text[i] == first and text[i+1] == second:
                res.append(text[i+2])
            i += 1
        
        return res



Day 039, 08/20/2020 Thu

1507. Reformat Date

cclass Solution:
    def reformatDate(self, date: str) -> str:
        '''
        Refromat date to format YYYY-MM-DD
        
            -type : date (str)
            -rtype: str
        '''
        
        # Splite date by spaces
        date = date.split(' ')
        
        # Remove chars in day
        date[0] = [x for x in date[0] if x.isnumeric()]
        date[0] = ''.join(date[0]) if len(date[0]) == 2 else '0'+date[0][0]
        
        import calendar
        date[1] = str(list(calendar.month_abbr).index(date[1]))
        date[1] = '0'+date[1] if len(date[1]) == 1 else date[1]
        
        return date[2] + '-' + date[1] + '-' + date[0]



1486. XOR Operation in an Array

class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        '''
        Create and find XOR of all elements of nums
            
            -type :     n (int)
                    start (int)
            -rtype: int
        '''
        # Create nums
        nums = [start + 2*i for i in range(n)] 
        
        # Return the bitwise XOR
        from functools import reduce
        return reduce(lambda x, y: x^y, nums)



0669. Trim a Binary Search Tree

class Solution:
    def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:
        


Day 040, 08/21/2020 Fri
Day 041, 08/22/2020 Sat
Day 042, 08/23/2020 Sun

Day 043, 08/24/2020 Mon

0160. Intersection of Two Linked Lists

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:



0763. Partition Labels

class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        '''
        Find size of each partiton part of S, where each letter appears in at most one part
        
            -type : S (str)
            -rtype: List[int]
        '''
        # Counter frequency of each letter
        from collections import Counter
        freq = Counter(S)
        
        # Convert S to list of chars
        S = list(S)
        
        # Initiate result as res
        res = []
        
        # Loop S (reversely).
        # Find partion points and record length of each partition.
        # Use a set to record all chars seen. If freq of this char is 0,
        # check if all othe chars in the set are also 0. 
        # If yes, partition poin found; else, continue.
        holder = set([])  # Remember uniqe chars from S
        cnt = 0           # Record length of current partition 
        while S:
            temp = S.pop() # Pop and record last char in S 
            freq[temp] -= 1
            holder.add(temp)
            cnt += 1
            if freq[temp] == 0:
                if sum([freq[x] for x in holder]) == 0: # Partiton point found
                    res.append(cnt)
                    # Reset holder and cnt #
                    holder = set([])
                    cnt = 0
        
        # Reverse res (since S is popped reversely)
        res.reverse()
        
        return res



Day 044, 08/25/2020 Tue



Day 045, 08/26/2020 Wed

0944. Delete Columns to Make Sorted

class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        '''
        Find the minimum possible length of D (delection set) s.t. 
        each remaining column in A is in non-decreasing sorted order
        
            -type : A (List[str])
            -rtype: int
        '''
        res = 0    # Initiate result, length of deletion set
        
        # Special case
        if len(A) == 1:
            return 0
            
        # Loop index i of each word in A.
        # If, for an index i, A[x-1][i] > A[x][i], incremnent res and start next index
        for i in range(len(A[0])):
            for x in range(1, len(A)):
                if A[x-1][i] > A[x][i]:
                    res += 1
                    break
        return res



1431. Kids With the Greatest Number of Candies

class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        '''
        Find if every kid in candies can have the greatest number of candies with extraCandies
        
            -type :      candies (List[int])
                    extraCandies (int)
            -rtype: List[bool]  
        '''
        # Find max of candies
        m = max(candies)
        
        # Loop candies.
        # Determine if ith candy + extraCandies >= m
        return [c+extraCandies >= m for c in candies]

        
        
0131. Palindrome Partitioning

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        '''
        Partition s such that every substring of the partition is a palindrome
        
            -type : s (str)
            -rtype: List[List[str]]
        '''
        if len(s) == 1:
            return [[s]]
        else:
            res = []
            i = 0
            while i < len(s)-1:
                if self.isPalindrome(s[:(i+1)]):
                    res.extend([[s[:(i+1)]] + x for x in self.partition(s[(i+1):])])
                i += 1
            if self.isPalindrome(s):
                res.append([s])
            return res

    def isPalindrome(self, s: str) -> bool:
        '''
        Determine if s is palindrome
        
            -type : s (str)
            -rtype: bool  
        '''
        # If empty, yes
        if not s:
            return False
        
        # Loop s from both ends and check
        i, j = 0, len(s) - 1
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True



Day 046, 08/27/2020 Thu
Day 047, 08/28/2020 Fri
Day 048, 08/29/2020 Sat
Day 049, 08/30/2020 Sun



Day 050, 08/31/2020 Mon

0938. Range Sum of BST

class Solution:
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
        '''
        Find the sum of node values between L and R, inclusive
            
            -type : root (TreeNode)
                       L (int)
                       R (int)
            -rtype: int
        '''
        # Check if root is NULL:
        if not root:
            return 0
        
        # If no child
        if not (root.left or root.right):
            return root.val if L <= root.val <= R else 0 
        
        # Check both left and right child
        if root.left and root.right:
            # Case when root value > R, then just search left child 
            if root.val > R:
                return self.rangeSumBST(root.left, L, R)
            # Case when root value < L, then just search right child 
            elif root.val < L:
                return self.rangeSumBST(root.right, L, R)
            # Otherwise, search both
            else:
                return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)
                
        # If only one child exists and root value in [L, R]
        if root.left and root.val >= L:
            return root.val + self.rangeSumBST(root.left, L, R)
        if root.right and root.val <= R:
            return root.val + self.rangeSumBST(root.right, L, R)
        else:
            return 0



1480. Running Sum of 1d Array

class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        '''
        Find the running sum of nums
        
            -type : nums (List[int])
            -rtype: List[int]
        '''
        res = nums[:]
        for i in range(1, len(res)):
            res[i] += res[i-1]
        return res



0017. Letter Combinations of a Phone Number

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        '''
        Find all possible word combinations of numbers in digits
        
            -type : digits (str)
            -rtype: List[str]        
        '''
        # Check if digits is empty
        if not digits:
            return []
        
        # Create a dictionary, d, to map int: char relationship 
        # in phon buttons
        import string
        d = {str(i):string.ascii_lowercase[(3*(i-2)):3*(i-2)+3] for i in range(2, 7)}
        d['7'] = 'pqrs'
        d['8'] = 'tuv'
        d['9'] = 'wxyz'
        
        # Use itertools to find all combinations, and reuse d as result
        from itertools import product
        from functools import reduce
        d = reduce(lambda x, y: product([''.join(ele) for ele in x], y), [list(d[i]) for i in digits])
        
        return [''.join(x) for x in d]
        
        

Day 051, 09/01/2020 Tue
Day 052, 09/02/2020 Wed

Day 053, 09/03/2020 Thu

0893. Groups of Special-Equivalent Strings

class Solution:
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        '''
        Find the number of groups of special-equivalent strings from A
        
            -type : A (List[str]) 
            -rtype: int
        '''
        # Convert all str in A to their equivalent str
        A = [self.equivalentString(s) for s in A]

        return len(set(A))
        
        
    def equivalentString(self, s: str) -> str:
        '''
        Convert s to its equivalent string, where chars in odd/even
        indices are in alphabetic orders
        
            -type : s (str)
            -rtype: str
        '''
        # Convert s to a list
        s = list(s)
        
        # Reorder s as sorted odd indexed eles + sorted even indexed eles
        s = sorted([x[1] for x in enumerate(s) if x[0]%2]) + sorted([x[1] for x in enumerate(s) if x[0]%2 == 0])
      
        return ''.join(s)
             
        
        
1413. Minimum Value to Get Positive Step by Step Sum

class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        '''
        Find the minimum positive value of startValue such that the step by step sum is never less than 1
        
            -type : nums (List[int])
            -rtype: int
        '''
        # Find the min step by step sum of nums
        minSum = currSum = nums[0]
        for i in range(1, len(nums)):
            currSum += nums[i]
            minSum = min(minSum, currSum)
        # Return max of 1 and 1 - minSum as min startValue
        return max(1, 1 - minSum)

        
        
0054. Spiral Matrix

class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        '''
        Return all elements of the matrix in spiral order.
        
            -type : matrix: List[List[int]]
            -rtype: List[int]
        '''
        # If matrix is empty, return []
        if not matrix:
            return []
        
        # Define row and column borders when moving in matrix
        r_low, r_high = 0, len(matrix)
        c_low, c_high = -1, len(matrix[0])
        
        # Define current poistion.
        i = j = 0
        
        # Define direction we move in matrix. Start with right.
        direction = 'right'
        
        # Loop  matrix in a spiral order
        res = []
        while r_low != r_high and c_low != c_high:
            if direction == 'right':
                while j < c_high:
                    res.append(matrix[i][j])
                    j += 1
                c_high -= 1
                j -= 1
                direction = 'down'
                i = min(r_high, i+1)
            elif direction == 'down':
                while i < r_high:
                    res.append(matrix[i][j])
                    i += 1
                r_high -= 1
                i -= 1
                direction = 'left'
                j = max(c_low, j-1)
            elif direction == 'left':
                while j > c_low:
                    res.append(matrix[i][j])
                    j -= 1
                c_low += 1
                j += 1
                direction = 'up'
                i = max(r_low, i-1)
            elif direction == 'up':
                while i > r_low:
                    res.append(matrix[i][j])
                    i -= 1
                r_low += 1
                i += 1
                direction = 'right'
                j = min(c_high, j+1)
            
        return res
        


Day 054, 09/04/2020 Fri
Day 055, 09/05/2020 Sat
Day 056, 09/06/2020 Sun
Day 057, 09/07/2020 Mon
Day 058, 09/08/2020 Tue


Day 059, 09/09/2020 Wed

0941. Valid Mountain Array

class Solution:
    def validMountainArray(self, A: List[int]) -> bool:
        '''
        Determine if A is a valild mountain array
        
            -type : A (List[int])
            -rtype: bool
        '''
        w = len(A)       # Define width of th mountain
        climbing = True  # Determine cuurent status: Climbing th mountain or not
        
        # Check if width of the mountain is > 3
        # And if start status is climbing the mountain
        if w < 3 or A[0] >= A[1]:
            return False
        
        # Loop the mountain startin with climbing.
        # If a flat walk found, or found a second time to climb the mountain, return False.
        # When first time see A[i-1] > A[i], convert climbing status.    
        for i in range(1, w):
            if A[i-1] == A[i] or (not climbing and A[i-1] < A[i]):
                return False
            elif climbing and A[i-1] > A[i]:
                climbing = False
        
        # If climbing is stil true at the end, then A is invalid. Otherwise, it is valid.
        return not climbing



1331. Rank Transform of an Array

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        '''
        Find rank (start from 1) of each element
        
            -type : arr (List[int])
            -rtype: List[int]
        '''
        # Use a dictionary to list rank for all unique eles
        res = {k:v for (v, k) in enumerate(sorted(set(arr)))}
        return [res[k] + 1 for k in arr]
        
        

1249. Minimum Remove to Make Valid Parentheses

class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        '''
        Remove the minimum number of parentheses to make s valid and return updated s
        
            -type: s (str)
            -rtpe: str
        '''
        # Record positions of left parentheses we see so far
        leftParentheses = []
        
        # Convert s to a list
        s = list(s)
        
        # Loop s using index.
        # If we see a left parenthesis, push its position to leftParentheses
        # If we see a right parenthesis and leftParentheses is not empty, pop leftParentheses
        # If leftParentheses is empty and we see a right parenthesis, then we need to remove this
        # right parenthesis -> convert s[i] to ''
        for i in range(len(s)):
            if s[i] == '(':
                leftParentheses.append(i)
            elif leftParentheses and s[i] == ')':
                leftParentheses.pop()
            elif s[i] == ')':
                s[i] = ''
        
        # Check if leftParentheses is empty
        # If not, we then need to convert '(' at positions in leftParentheses to ''
        if leftParentheses:
            for i in leftParentheses:
                s[i] = ''
        
        return ''.join(s)
        


Day 060, 09/10/2020 Thu

0703. Kth Largest Element in a Stream

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        

    def add(self, val: int) -> int:
        


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)



0012. Integer to Roman

class Solution:
    def intToRoman(self, num: int) -> str:
        '''
        Convert num to a roman numeral
        
            -type : num(int)
            -rtype: str
        '''
        # Create a dictionary, d, to map integer -> Roman numeral 
        d = {1:'I', 5:'V', 10:'X', 50:'L', 100:'C', 500:'D', 1000:'M', 4:'IV', 9:'IX', 40:'XL', 90:'XC', 400:'CD', 900:'CM'}
        
        # Create a modifier and a divider, then loop num until num == 0
        # In each loop, set remainder = num%divider, and concat remainder's
        # Roman numeral conversion to res (If remainder in d, else seard remainder/(divider/10) in d)
        # and multiply divider by 10
        # Then set num = numn - remainder
        res = ''
        divider = 10
        while num > 0:
            remainder = num%divider
            if remainder and remainder in d:
                res = d[remainder] + res
            elif remainder:
                m = 10*remainder//divider
                # Need to consider case when 5, 50 and 500
                if m > 5:
                    res = d[5*divider//10] + (m-5)*d[remainder//m] + res
                else:
                    res = m*d[remainder//m] + res
            divider *= 10             
            num -= remainder 
        return res
        
        

0199. Binary Tree Right Side View



Day 061, 09/11/2020 Fri

0108. Convert Sorted Array to Binary Search Tree

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        '''
        Convert num (sorted) to a height balanced BST
        
            -type : nums (List[int])
            -rtype: TreeNode
        '''
        l = len(nums)
        
        # Check if the list is empty
        if not nums:
            return None
          
        # Set mid value as the root of the (sub)tree
        root = TreeNode(val = nums[l//2])
        
        # Check if left/right subtree shoudl exsit and set them up
        root.left = self.sortedArrayToBST(nums[:l//2]) if l//2 > 0 else None
        root.right = self.sortedArrayToBST(nums[l//2+1:]) if l/2 > 1 else None
        
        return root



0152. Maximum Product Subarray



0981. Time Based Key-Value Store



Day 062, 09/12/2020 Sat
Day 063, 09/13/2020 Sun



Day 064, 09/14/2020 Mon

0170. Two Sum III - Data structure design

class TwoSum:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = {}
        

    def add(self, number: int) -> None:
        """
        Add the number to an internal data structure..
        """
        if number in self.d:
            self.d[number] += 1
        else:
            self.d[number] = 1

    def find(self, value: int) -> bool:
        """
        Find if there exists any pair of numbers which sum is equal to the value.
        """
        for k in self.d:
            if value - k in self.d and (value - k != k or (value == 2*k and self.d[k] > 1)):
                return True  
        
        return False


0064. Minimum Path Sum



0347. Top K Frequent Elements

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        '''
        Find the top K mist frequent ele in nums
            
            -types: nums (List[int])
                       k (int)
            -rtype: List[int]
        '''
        # Use Counter
        from collections import Counter
        nums = Counter(nums)
        nums = nums.most_common(k)
        return [x[0] for x in nums]        




Day 065, 09/15/2020 Tue


Day 066, 09/16/2020 Wed

0687. Longest Univalue Path


        
0078. Subsets

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        '''
        Find all possible nums' subsets
            
            - type : nums (List[int])
            - rtype: List[List[int]
        '''
        # Initiate result, res, from a list contains only empty set
        res = [[]]
        
        # Case when nums is empty
        if not nums:
            return res
        
        # Use itertools.combinations to find all required subsets
        from itertools import combinations
        for i in range(1, len(nums)):
            res.extend([list(x) for x in combinations(nums, i)])
        
        # Include nums itself in the end
        res.append(nums)
        return res



1262. Greatest Sum Divisible by Three

class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        '''
        Find the maximum possible sum of elements of the array such that it is divisible by 3.

            -type : nums (List[int])
            -rtype: int
        '''
        # Create a list, res, with length = length of nums.
        # Each ele in res is a list, where index of each ele
        # will record current largest sum that mod 3 = index
        res = [[0, 0, 0] for _ in range(len(nums))]
        res[0][nums[0]%3] = nums[0]
        
        # Loop nums and find max of current sum where mod 3 = 0, 1 or 2, based on previous sums and current ele.
        for i in range(1, len(nums)):
            for j in range(3):
                temp = [nums[i]+x for x in res[i-1] if (nums[i]+x)%3 == j]
                res[i][j] = max(max(temp), res[i-1][j]) if temp else res[i-1][j]
          
        return res[-1][0]



Day 067, 09/17/2020 Thu

0704. Binary Search

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        

0646. Maximum Length of Pair Chain

class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
     

0148. Sort List

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        



Day 068, 09/18/2020 Fri
Day 069, 09/19/2020 Sat
Day 070, 09/20/2020 Sun

