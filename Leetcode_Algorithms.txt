Day 001, 07/13/2020 Mon
Day 002, 07/14/2020 Tue
Day 003, 07/15/2020 Wed
Day 004, 07/16/2020 Thu
Day 005, 07/17/2020 Fri
Day 006, 07/18/2020 Sat
Day 007, 07/19/2020 Sun
Day 008, 07/20/2020 Mon
Day 009, 07/21/2020 Tue
Day 010, 07/22/2020 Wed
Day 011, 07/23/2020 Thu
Day 012, 07/24/2020 Fri
Day 013, 07/25/2020 Sat
Day 014, 07/26/2020 Sun
Day 015, 07/27/2020 Mon
Day 016, 07/28/2020 Tue
Day 017, 07/29/2020 Wed
Day 018, 07/30/2020 Thu
Day 019, 07/31/2020 Fri
Day 020, 08/01/2020 Sat
Day 021, 08/02/2020 Sun
Day 022, 08/03/2020 Mon
Day 023, 08/04/2020 Tue
Day 024, 08/05/2020 Wed
Day 025, 08/06/2020 Thu
Day 026, 08/07/2020 Fri
Day 027, 08/08/2020 Sat
Day 028, 08/09/2020 Sun
Day 029, 08/10/2020 Mon
Day 030, 08/11/2020 Tue
Day 031, 08/12/2020 Wed
Day 032, 08/13/2020 Thu
Day 033, 08/14/2020 Fri
Day 034, 08/15/2020 Sat
Day 035, 08/16/2020 Sun

Day 036, 08/17/2020 Mon

1385. Find the Distance Value Between Two Arrays

class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        '''
        Find the distance between arr1 and arr2.
        
            types: arr1 (List[int])
                   arr2 (List[int])   
                      d (int)
            rtype: int
        '''
        return sum([not any([abs(x - y) <= d for y in arr2]) for x in arr1])



0748. Shortest Completing Word

class Solution:
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        '''
        Find the minimum length word from a given dictionary words, 
        which has all the letters from the string licensePlate.
        
            types: licensePlate (str) 
                          words (List[str])
            rtype: str
        '''
        # Filter out non-alphabetics chars in licensePlate,
        # and convert all chars to lower case.
        licensePlate = list(licensePlate)
        licensePlate = [x.lower() for x in licensePlate if x.isalpha()]
        licensePlate = ''.join(licensePlate)
        
        # Convert all letters in words to lower case
        words = [x.lower() for x in words]
        
        # Use counter to find the first word such that licensePlate is a subset of it.
        # If it is, then check if current word has smaller length and res. If yes, then 
        # assign this word to res. Otherwise, continue.
        res = 'a'*1000
        from collections import Counter
        plate_cnt = Counter(licensePlate)
        for word in words:
            cnt = Counter(word)
            if len(cnt - plate_cnt) >= 0 and len(plate_cnt - cnt) == 0:
                if len(word) < len(res):
                    res = word
        return res



0949. Largest Time for Given Digits

class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        '''
        Find the largest 24 hour time that can be made. 
        If no valid time can be made, return an empty string.
        
            type : A (List[int])
            rtype: str
        '''
        # Initiate result, res
        res = ''
        
        # Loop A. For each loop, find the largest legal hour, and 
        # check if min will also will be legal.
        current_h = current_m = -1
        for i in range(4):
            for j in range(4):
                # Create largest legal hour using two different ele
                if i != j and current_h <= 10*A[i] + A[j] < 24:
                    # Check if the other two eles and create legal min.
                    # If yes, find the largest one.
                    minute = [A[x] for x in range(4) if x not in [i, j]]
                    minute = [10 * minute[0] + minute[1], 10 * minute[1] + minute[0]]
                    minute = [x for x in minute if x < 60]
                    
                    if minute:
                        if 10*A[i] + A[j] == current_h and current_m < max(minute):
                                current_m = max(minute)
                        elif 10*A[i] + A[j] > current_h:
                                current_h = 10*A[i] + A[j]
                                current_m = max(minute)
                            
        if current_h == -1 and current_m == -1:
            return ''
        # Add leading zero if either of current_h or current_m is < 10
        current_h = '0' + str(current_h) if current_h < 10 else str(current_h)
        current_m = '0' + str(current_m) if current_m < 10 else str(current_m)
        
        return current_h  + ":" + current_m


Day 037, 08/18/2020 Tue



Day 038, 08/19/2020 Wed

1317. Convert Integer to the Sum of Two No-Zero Integers

class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        '''
        Convert n to the sum of two integers without 0
        
            -type : n (int)
            -rtype: List[int]
        '''
        # Loop n from 1 to n//2.
        # If neither of x or n-x contains 0, then return [x, n-x] 
        for x in range(1, n//2+1):
            if '0' not in str(x) and '0' not in str(n-x):
                return [x, n-x]



0257. Binary Tree Paths

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:



1078. Occurrences After Bigram

class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        '''
        Find all words after occurences of first and second word
        
            -type : text (str)
            -type : first (str)
            -type : second (str)
            -rtype: List[str]
        '''
        # Spilt text to a list
        text = text.split(' ')
        
        # Loop text and find such a pattern
        i = 0
        l = len(text) - 2
        res = []
        while i < l:
            if text[i] == first and text[i+1] == second:
                res.append(text[i+2])
            i += 1
        
        return res



Day 039, 08/20/2020 Thu

1507. Reformat Date

cclass Solution:
    def reformatDate(self, date: str) -> str:
        '''
        Refromat date to format YYYY-MM-DD
        
            -type : date (str)
            -rtype: str
        '''
        
        # Splite date by spaces
        date = date.split(' ')
        
        # Remove chars in day
        date[0] = [x for x in date[0] if x.isnumeric()]
        date[0] = ''.join(date[0]) if len(date[0]) == 2 else '0'+date[0][0]
        
        import calendar
        date[1] = str(list(calendar.month_abbr).index(date[1]))
        date[1] = '0'+date[1] if len(date[1]) == 1 else date[1]
        
        return date[2] + '-' + date[1] + '-' + date[0]



1486. XOR Operation in an Array

class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        '''
        Create and find XOR of all elements of nums
            
            -type :     n (int)
                    start (int)
            -rtype: int
        '''
        # Create nums
        nums = [start + 2*i for i in range(n)] 
        
        # Return the bitwise XOR
        from functools import reduce
        return reduce(lambda x, y: x^y, nums)



0669. Trim a Binary Search Tree

class Solution:
    def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:
        


Day 040, 08/21/2020 Fri
Day 041, 08/22/2020 Sat
Day 042, 08/23/2020 Sun

Day 043, 08/24/2020 Mon

0160. Intersection of Two Linked Lists

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:



0763. Partition Labels

class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        '''
        Find size of each partiton part of S, where each letter appears in at most one part
        
            -type : S (str)
            -rtype: List[int]
        '''
        # Counter frequency of each letter
        from collections import Counter
        freq = Counter(S)
        
        # Convert S to list of chars
        S = list(S)
        
        # Initiate result as res
        res = []
        
        # Loop S (reversely).
        # Find partion points and record length of each partition.
        # Use a set to record all chars seen. If freq of this char is 0,
        # check if all othe chars in the set are also 0. 
        # If yes, partition poin found; else, continue.
        holder = set([])  # Remember uniqe chars from S
        cnt = 0           # Record length of current partition 
        while S:
            temp = S.pop() # Pop and record last char in S 
            freq[temp] -= 1
            holder.add(temp)
            cnt += 1
            if freq[temp] == 0:
                if sum([freq[x] for x in holder]) == 0: # Partiton point found
                    res.append(cnt)
                    # Reset holder and cnt #
                    holder = set([])
                    cnt = 0
        
        # Reverse res (since S is popped reversely)
        res.reverse()
        
        return res



Day 044, 08/25/2020 Tue



Day 045, 08/26/2020 Wed

0944. Delete Columns to Make Sorted

class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        '''
        Find the minimum possible length of D (delection set) s.t. 
        each remaining column in A is in non-decreasing sorted order
        
            -type : A (List[str])
            -rtype: int
        '''
        res = 0    # Initiate result, length of deletion set
        
        # Special case
        if len(A) == 1:
            return 0
            
        # Loop index i of each word in A.
        # If, for an index i, A[x-1][i] > A[x][i], incremnent res and start next index
        for i in range(len(A[0])):
            for x in range(1, len(A)):
                if A[x-1][i] > A[x][i]:
                    res += 1
                    break
        return res



1431. Kids With the Greatest Number of Candies

class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        '''
        Find if every kid in candies can have the greatest number of candies with extraCandies
        
            -type :      candies (List[int])
                    extraCandies (int)
            -rtype: List[bool]  
        '''
        # Find max of candies
        m = max(candies)
        
        # Loop candies.
        # Determine if ith candy + extraCandies >= m
        return [c+extraCandies >= m for c in candies]

        
        
0131. Palindrome Partitioning

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        '''
        Partition s such that every substring of the partition is a palindrome
        
            -type : s (str)
            -rtype: List[List[str]]
        '''
        if len(s) == 1:
            return [[s]]
        else:
            res = []
            i = 0
            while i < len(s)-1:
                if self.isPalindrome(s[:(i+1)]):
                    res.extend([[s[:(i+1)]] + x for x in self.partition(s[(i+1):])])
                i += 1
            if self.isPalindrome(s):
                res.append([s])
            return res

    def isPalindrome(self, s: str) -> bool:
        '''
        Determine if s is palindrome
        
            -type : s (str)
            -rtype: bool  
        '''
        # If empty, yes
        if not s:
            return False
        
        # Loop s from both ends and check
        i, j = 0, len(s) - 1
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True



Day 046, 08/27/2020 Thu
Day 047, 08/28/2020 Fri
Day 048, 08/29/2020 Sat
Day 049, 08/30/2020 Sun



Day 050, 08/31/2020 Mon

0938. Range Sum of BST

class Solution:
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
        '''
        Find the sum of node values between L and R, inclusive
            
            -type : root (TreeNode)
                       L (int)
                       R (int)
            -rtype: int
        '''
        # Check if root is NULL:
        if not root:
            return 0
        
        # If no child
        if not (root.left or root.right):
            return root.val if L <= root.val <= R else 0 
        
        # Check both left and right child
        if root.left and root.right:
            # Case when root value > R, then just search left child 
            if root.val > R:
                return self.rangeSumBST(root.left, L, R)
            # Case when root value < L, then just search right child 
            elif root.val < L:
                return self.rangeSumBST(root.right, L, R)
            # Otherwise, search both
            else:
                return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)
                
        # If only one child exists and root value in [L, R]
        if root.left and root.val >= L:
            return root.val + self.rangeSumBST(root.left, L, R)
        if root.right and root.val <= R:
            return root.val + self.rangeSumBST(root.right, L, R)
        else:
            return 0



1480. Running Sum of 1d Array

class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        '''
        Find the running sum of nums
        
            -type : nums (List[int])
            -rtype: List[int]
        '''
        res = nums[:]
        for i in range(1, len(res)):
            res[i] += res[i-1]
        return res



0017. Letter Combinations of a Phone Number

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        '''
        Find all possible word combinations of numbers in digits
        
            -type : digits (str)
            -rtype: List[str]        
        '''
        # Check if digits is empty
        if not digits:
            return []
        
        # Create a dictionary, d, to map int: char relationship 
        # in phon buttons
        import string
        d = {str(i):string.ascii_lowercase[(3*(i-2)):3*(i-2)+3] for i in range(2, 7)}
        d['7'] = 'pqrs'
        d['8'] = 'tuv'
        d['9'] = 'wxyz'
        
        # Use itertools to find all combinations, and reuse d as result
        from itertools import product
        from functools import reduce
        d = reduce(lambda x, y: product([''.join(ele) for ele in x], y), [list(d[i]) for i in digits])
        
        return [''.join(x) for x in d]
        
        

Day 051, 09/01/2020 Tue
Day 052, 09/02/2020 Wed

Day 053, 09/03/2020 Thu

0893. Groups of Special-Equivalent Strings

class Solution:
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        '''
        Find the number of groups of special-equivalent strings from A
        
            -type : A (List[str]) 
            -rtype: int
        '''
        # Convert all str in A to their equivalent str
        A = [self.equivalentString(s) for s in A]

        return len(set(A))
        
        
    def equivalentString(self, s: str) -> str:
        '''
        Convert s to its equivalent string, where chars in odd/even
        indices are in alphabetic orders
        
            -type : s (str)
            -rtype: str
        '''
        # Convert s to a list
        s = list(s)
        
        # Reorder s as sorted odd indexed eles + sorted even indexed eles
        s = sorted([x[1] for x in enumerate(s) if x[0]%2]) + sorted([x[1] for x in enumerate(s) if x[0]%2 == 0])
      
        return ''.join(s)
             
        
        
1413. Minimum Value to Get Positive Step by Step Sum

class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        '''
        Find the minimum positive value of startValue such that the step by step sum is never less than 1
        
            -type : nums (List[int])
            -rtype: int
        '''
        # Find the min step by step sum of nums
        minSum = currSum = nums[0]
        for i in range(1, len(nums)):
            currSum += nums[i]
            minSum = min(minSum, currSum)
        # Return max of 1 and 1 - minSum as min startValue
        return max(1, 1 - minSum)

        
        
0054. Spiral Matrix

class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        '''
        Return all elements of the matrix in spiral order.
        
            -type : matrix: List[List[int]]
            -rtype: List[int]
        '''
        # If matrix is empty, return []
        if not matrix:
            return []
        
        # Define row and column borders when moving in matrix
        r_low, r_high = 0, len(matrix)
        c_low, c_high = -1, len(matrix[0])
        
        # Define current poistion.
        i = j = 0
        
        # Define direction we move in matrix. Start with right.
        direction = 'right'
        
        # Loop  matrix in a spiral order
        res = []
        while r_low != r_high and c_low != c_high:
            if direction == 'right':
                while j < c_high:
                    res.append(matrix[i][j])
                    j += 1
                c_high -= 1
                j -= 1
                direction = 'down'
                i = min(r_high, i+1)
            elif direction == 'down':
                while i < r_high:
                    res.append(matrix[i][j])
                    i += 1
                r_high -= 1
                i -= 1
                direction = 'left'
                j = max(c_low, j-1)
            elif direction == 'left':
                while j > c_low:
                    res.append(matrix[i][j])
                    j -= 1
                c_low += 1
                j += 1
                direction = 'up'
                i = max(r_low, i-1)
            elif direction == 'up':
                while i > r_low:
                    res.append(matrix[i][j])
                    i -= 1
                r_low += 1
                i += 1
                direction = 'right'
                j = min(c_high, j+1)
            
        return res
        


Day 054, 09/04/2020 Fri
Day 055, 09/05/2020 Sat
Day 056, 09/06/2020 Sun
Day 057, 09/07/2020 Mon
Day 058, 09/08/2020 Tue


Day 059, 09/09/2020 Wed

0941. Valid Mountain Array

class Solution:
    def validMountainArray(self, A: List[int]) -> bool:
        '''
        Determine if A is a valild mountain array
        
            -type : A (List[int])
            -rtype: bool
        '''
        w = len(A)       # Define width of th mountain
        climbing = True  # Determine cuurent status: Climbing th mountain or not
        
        # Check if width of the mountain is > 3
        # And if start status is climbing the mountain
        if w < 3 or A[0] >= A[1]:
            return False
        
        # Loop the mountain startin with climbing.
        # If a flat walk found, or found a second time to climb the mountain, return False.
        # When first time see A[i-1] > A[i], convert climbing status.    
        for i in range(1, w):
            if A[i-1] == A[i] or (not climbing and A[i-1] < A[i]):
                return False
            elif climbing and A[i-1] > A[i]:
                climbing = False
        
        # If climbing is stil true at the end, then A is invalid. Otherwise, it is valid.
        return not climbing



1331. Rank Transform of an Array

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        '''
        Find rank (start from 1) of each element
        
            -type : arr (List[int])
            -rtype: List[int]
        '''
        # Use a dictionary to list rank for all unique eles
        res = {k:v for (v, k) in enumerate(sorted(set(arr)))}
        return [res[k] + 1 for k in arr]
        
        

1249. Minimum Remove to Make Valid Parentheses

class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        '''
        Remove the minimum number of parentheses to make s valid and return updated s
        
            -type: s (str)
            -rtype: str
        '''
        # Record positions of left parentheses we see so far
        leftParentheses = []
        
        # Convert s to a list
        s = list(s)
        
        # Loop s using index.
        # If we see a left parenthesis, push its position to leftParentheses
        # If we see a right parenthesis and leftParentheses is not empty, pop leftParentheses
        # If leftParentheses is empty and we see a right parenthesis, then we need to remove this
        # right parenthesis -> convert s[i] to ''
        for i in range(len(s)):
            if s[i] == '(':
                leftParentheses.append(i)
            elif leftParentheses and s[i] == ')':
                leftParentheses.pop()
            elif s[i] == ')':
                s[i] = ''
        
        # Check if leftParentheses is empty
        # If not, we then need to convert '(' at positions in leftParentheses to ''
        if leftParentheses:
            for i in leftParentheses:
                s[i] = ''
        
        return ''.join(s)
        


Day 060, 09/10/2020 Thu

0703. Kth Largest Element in a Stream

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        

    def add(self, val: int) -> int:
        


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)



0012. Integer to Roman

class Solution:
    def intToRoman(self, num: int) -> str:
        '''
        Convert num to a roman numeral
        
            -type : num(int)
            -rtype: str
        '''
        # Create a dictionary, d, to map integer -> Roman numeral 
        d = {1:'I', 5:'V', 10:'X', 50:'L', 100:'C', 500:'D', 1000:'M', 4:'IV', 9:'IX', 40:'XL', 90:'XC', 400:'CD', 900:'CM'}
        
        # Create a modifier and a divider, then loop num until num == 0
        # In each loop, set remainder = num%divider, and concat remainder's
        # Roman numeral conversion to res (If remainder in d, else seard remainder/(divider/10) in d)
        # and multiply divider by 10
        # Then set num = numn - remainder
        res = ''
        divider = 10
        while num > 0:
            remainder = num%divider
            if remainder and remainder in d:
                res = d[remainder] + res
            elif remainder:
                m = 10*remainder//divider
                # Need to consider case when 5, 50 and 500
                if m > 5:
                    res = d[5*divider//10] + (m-5)*d[remainder//m] + res
                else:
                    res = m*d[remainder//m] + res
            divider *= 10             
            num -= remainder 
        return res
        
        

0199. Binary Tree Right Side View



Day 061, 09/11/2020 Fri

0108. Convert Sorted Array to Binary Search Tree

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        '''
        Convert num (sorted) to a height balanced BST
        
            -type : nums (List[int])
            -rtype: TreeNode
        '''
        l = len(nums)
        
        # Check if the list is empty
        if not nums:
            return None
          
        # Set mid value as the root of the (sub)tree
        root = TreeNode(val = nums[l//2])
        
        # Check if left/right subtree shoudl exsit and set them up
        root.left = self.sortedArrayToBST(nums[:l//2]) if l//2 > 0 else None
        root.right = self.sortedArrayToBST(nums[l//2+1:]) if l/2 > 1 else None
        
        return root



0152. Maximum Product Subarray



0981. Time Based Key-Value Store



Day 062, 09/12/2020 Sat
Day 063, 09/13/2020 Sun



Day 064, 09/14/2020 Mon

0170. Two Sum III - Data structure design

class TwoSum:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = {}
        

    def add(self, number: int) -> None:
        """
        Add the number to an internal data structure..
        """
        if number in self.d:
            self.d[number] += 1
        else:
            self.d[number] = 1

    def find(self, value: int) -> bool:
        """
        Find if there exists any pair of numbers which sum is equal to the value.
        """
        for k in self.d:
            if value - k in self.d and (value - k != k or (value == 2*k and self.d[k] > 1)):
                return True  
        
        return False


0064. Minimum Path Sum



0347. Top K Frequent Elements

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        '''
        Find the top K mist frequent ele in nums
            
            -types: nums (List[int])
                       k (int)
            -rtype: List[int]
        '''
        # Use Counter
        from collections import Counter
        nums = Counter(nums)
        nums = nums.most_common(k)
        return [x[0] for x in nums]        




Day 065, 09/15/2020 Tue


Day 066, 09/16/2020 Wed

0687. Longest Univalue Path


        
0078. Subsets

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        '''
        Find all possible nums' subsets
            
            - type : nums (List[int])
            - rtype: List[List[int]
        '''
        # Initiate result, res, from a list contains only empty set
        res = [[]]
        
        # Case when nums is empty
        if not nums:
            return res
        
        # Use itertools.combinations to find all required subsets
        from itertools import combinations
        for i in range(1, len(nums)):
            res.extend([list(x) for x in combinations(nums, i)])
        
        # Include nums itself in the end
        res.append(nums)
        return res



1262. Greatest Sum Divisible by Three

class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        '''
        Find the maximum possible sum of elements of the array such that it is divisible by 3.

            -type : nums (List[int])
            -rtype: int
        '''
        # Create a list, res, with length = length of nums.
        # Each ele in res is a list, where index of each ele
        # will record current largest sum that mod 3 = index
        res = [[0, 0, 0] for _ in range(len(nums))]
        res[0][nums[0]%3] = nums[0]
        
        # Loop nums and find max of current sum where mod 3 = 0, 1 or 2, based on previous sums and current ele.
        for i in range(1, len(nums)):
            for j in range(3):
                temp = [nums[i]+x for x in res[i-1] if (nums[i]+x)%3 == j]
                res[i][j] = max(max(temp), res[i-1][j]) if temp else res[i-1][j]
          
        return res[-1][0]



Day 067, 09/17/2020 Thu



Day 068, 09/18/2020 Fri

0704. Binary Search

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        '''
        Find index of target in nums (sorted) if it exists. Otherwise, -1
        
            -type : nums   (List[int]) 
                    target (int)
            -rtype: int
        '''
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right)//2
            
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
            
        return -1



0646. Maximum Length of Pair Chain

class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
             





0148. Sort List

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        




Day 069, 09/19/2020 Sat
Day 070, 09/20/2020 Sun

1118. Number of Days in a Month

class Solution:
    def numberOfDays(self, Y: int, M: int) -> int:
        '''
        Find how many days there are in year Y and a month M
        
            -type : Y (int) 
                    M (int)
            -rtype: int
        '''
        # For big months,
        if M in [1,3,5,7,8,10,12]:
            return 31
        # for samll months, except Feb
        elif M in [4,6,9,11]:
            return 30
        elif Y%400 == 0 or (Y%4 == 0 and Y%100 != 0):
            return 29
        else:
            return 28
            
        

0636. Exclusive Time of Functions

                    
                    
0987. Vertical Order Traversal of a Binary Tree

class Solution:
    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
       



Day 071, 09/21/2020 Mon

1544. Make The String Great

class Solution:
    def makeGood(self, s: str) -> str:
        '''
        Find the string after making it good. 
        
            -type : s (str)
            -rtype: str
        '''
        # Loop s.
        # Using a stack to hold each ele.
        # Once find current ele = last ele in stack after
        # lower/upper conversion, pop stack.
        stack = []
        for x in s:
            if stack and x.islower() == stack[-1].isupper() and x.lower() == stack[-1].lower():
                stack.pop()   
            else:
                stack.append(x)

        # Return ele in stack in the form of a list
        return ''.join(stack)        



0300. Longest Increasing Subsequence

0767. Reorganize String


Day 072, 09/22/2020 Tue
Day 073, 09/23/2020 Wed
Day 074, 09/24/2020 Thu
Day 075, 09/25/2020 Fri
Day 076, 09/26/2020 Sat
Day 077, 09/27/2020 Sun


Day 078, 09/28/2020 Mon

0111. Minimum Depth of Binary Tree

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        '''
        Find minimum depth in the tree.
        
            -type : root (TreeNode) 
            -rtype: int
        '''
        
        def traverseTree(root: TreeNode) -> int:
            if not root:
                return 0
            elif not (root.left or root.right):
                return 1
            elif root.left and not root.right:
                return 1 + traverseTree(root.left)
            elif not root.left and root.right:
                return 1 + traverseTree(root.right)
            else:
                return 1 + min(traverseTree(root.left), traverseTree(root.right))     
        
        return traverseTree(root)



0018. 4Sum       

0692. Top K Frequent Words

class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        '''
        Find the k most frequent elements.
        
            -types: words (List[str]) 
                        k (int)
            -rtype: List[str]
        '''
        # Use counter to count and sort words by frequency
        from collections import Counter
        words = Counter(words)
        words = words.most_common()
        
        # Find the top K
        # In case same freqs occur, need to order words in this case alphabetically
        res = []
        i, l = 0, len(words)
        while i < k and i < l:
            temp = []
            while i < l-1 and words[i][1] == words[i+1][1]:
                temp.append(words[i][0])
                i += 1
            temp.append(words[i][0])
            temp.sort()
            res.extend(temp)             
            i += 1

        return res[:k]



Day 079, 09/29/2020 Tue


Day 080, 09/30/2020 Wed

0257. Binary Tree Paths

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root:
            return []
        appendix = self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)
        return [str(root.val) + '->' + str(x) for x in appendix] if appendix else [str(root.val)]



class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        width = len(matrix)
        ru, rd = 0, width-1
        cl, cr = 0, width-1
        
        # Rotate one by one from outmost circle to innermost circle
        while width > 1:
            for i in range(width-1):    
                temp, matrix[ru+i][cr] = matrix[ru+i][cr] ,matrix[ru][cl+i]
                temp, matrix[rd][cr-i] = matrix[rd][cr-i], temp
                temp, matrix[rd-i][cl] = matrix[rd-i][cl], temp
                matrix[ru][cl+i] = temp
  
            ru += 1
            rd -= 1
            cl += 1
            cr -= 1
            width -= 2



Day 081, 10/01/2020 Thu

0287. Find the Duplicate Number

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        '''
        Find the only duplicate in nums
        
            -  type: nums (List[int])
            - rtype: int 
        '''
        # Sort nums
        nums.sort()
        
        # Loop nums from the start and once nums[i-1] == nums[i],
        # return nums[i]
        for i in range(1, len(nums)):
            if nums[i-1] == nums[i]:
                return nums[i]



Day 082, 10/02/2020 Fri

1351. Count Negative Numbers in a Sorted Matrix

0974. Subarray Sums Divisible by K

1048. Longest String Chain



Day 083, 10/03/2020 Sat
Day 084, 10/04/2020 Sun
Day 085, 10/05/2020 Mon
Day 086, 10/06/2020 Tue
Day 087, 10/07/2020 Wed



Day 088, 10/08/2020 Thu

0110. Balanced Binary Tree

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:



0540. Single Element in a Sorted Array

class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        '''
        Find the only non duplicate in nums
        
            - type: nums (List[int])
            -rtype: int
        '''
        # Use exclusive OR in bit operation
        from functools import reduce
        return reduce(lambda x, y: x ^ y, nums)


Day 089, 10/09/2020 Fri

1550. Three Consecutive Odds

class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        '''
        Determine if there are 3 consecutive odd numbers in arr
            
            - type: arr(List[int])
            -rtype: bool
        '''
        # Create a variable, consective_odds, to record consecutive odd numbers.
        # Loop arr. If see an even number, set consective_odds = 0.
        # Else, consective_odds + 1.
        # Return True if consective_odds == 3
        consective_odds = 0
        
        i, l = 0, len(arr)
        
        while i < l:
            consective_odds = consective_odds + 1 if arr[i]%2 else 0
            if consective_odds == 3:
                return True
            i += 1



0946. Validate Stack Sequences

class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        '''
        Determine if pushed and popped could be valid operations of a stack
        
            -types: pushed (List[int]) 
                    popped (List[int])
            -rtype: bool
        '''
        # Create a stack to mock operations in pushed and popped.
        # In parallel, use two pointers, i and j, to loop eles in 
        # pushed and popped.
        stack = []
        i = j = 0
        l_pushed, l_popped = len(pushed), len(popped)
        
        while i != l_pushed or j != l_popped:
            if i < l_pushed:
                stack.append(pushed[i])
                while stack and stack[-1] == popped[j]:
                    stack.pop()
                    j += 1
                i += 1
            elif stack and stack[-1] == popped[j]:
                stack.pop()
                j += 1
            else:
                return False

        return stack == []



Day 090, 10/10/2020 Sat
Day 091, 10/11/2020 Sun
Day 092, 10/12/2020 Mon
Day 093, 10/13/2020 Tue


Day 094, 10/14/2020 Wed

0543. Diameter of Binary Tree

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        '''
        Find the length of the diameter of the tree. 
        
            -type : root (TreeNode)
            -rtype: int
        '''
        
        def maxDepth(root: TreeNode) -> int:
            '''
            Find the length max depth the tree. 

                -type : root (TreeNode)
                -rtype: int            
            '''
            if not (root and (root.left or root.right)):
                return 0
            else:
                return 1 + max(maxDepth(root.left), maxDepth(root.right))
            
        if not root or not (root.left or root.right):
            return 0
        elif root.left and not root.right:
            return 1 + maxDepth(root.left)
        elif not root.left and root.right:
            return 1 + maxDepth(root.right)
        else:
            return 2 + maxDepth(root.left) + maxDepth(root.right)



1523. Count Odd Numbers in an Interval Range

class Solution:
    def countOdds(self, low: int, high: int) -> int:
        '''
        Find the count of odd numbers between low and high (inclusive)
        
            -types: low  (int)
                    high (int)
            -rtype: int
        '''
        return (high - low + 1)//2 + ((high - low + 1)%2) * (low%2)


Day 095, 10/15/2020 Thu
Day 096, 10/16/2020 Fri

0200. Number of Islands



Day 097, 10/17/2020 Sat
Day 098, 10/18/2020 Sun
Day 099, 10/19/2020 Mon
Day 100, 10/20/2020 Tue
Day 101, 10/21/2020 Wed
Day 102, 10/22/2020 Thu
Day 103, 10/23/2020 Fri
Day 104, 10/24/2020 Sat
Day 105, 10/25/2020 Sun



Day 106, 10/26/2020 Mon

0892. Surface Area of 3D Shapes
            

0209. Minimum Size Subarray Sum

class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        '''
        Find the minimal length of a contiguous subarray of which the sum ≥ s
            
            -types:    s (int)
                    nums (List[int])    
            -rtype: int
        '''
        # Find length of nums
        l = len(nums)
        
        # Initiate result, subSum btw two pointers and start and end pointers
        subSum = nums[0]
        if subSum >= s:
            res = 1
            start = end = 0
        else:
            res = l
            start, end = 0, 1
        
        # Loop nums
        while start <= end or end < l: 
            if subSum < s:
                end += 1
                subSum += nums[end]
            else:
                res = min(res, end - start + 1)
                subSum -= nums[start]
                if start == end:
                    end += 1
                end = min(l-1, end)
                start += 1

        return res



Day 107, 10/27/2020 Tue



Day 108, 10/28/2020 Wed

0141. Linked List Cycle

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        '''
        Determine if head has a cycle
        
            -type : head (ListNode)
            -rtype: bool
        '''
        # Use a slow and a fast pointers to traverse the list.
        # If the two pointers meet, there is a cycle. Otherwise, no.
        slow = head if head else None
        slow = head if head else None
        slow = head if head else None
        fast = head.next.next if head and head.next else None
        
        while slow and fast:
            if slow and fast and slow.val == fast.val:
                return True
            slow = slow.next
            fast = fast.next.next if fast and fast.next else None
        return False



1022. Sum of Root To Leaf Binary Numbers

   

Day 109, 10/29/2020 Thu
Day 110, 10/30/2020 Fri
Day 111, 10/31/2020 Sat
Day 112, 11/01/2020 Sun


Day 113, 10/02/2020 Mon

0235. Lowest Common Ancestor of a Binary Search Tree

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        '''
        Find the lowest common ancestor of p and q.
        
            -types: p (TreeNode)
                    q (TreeNode)
            -rtype: TreeNode
        '''
        # Make the node that has smaller value as p
        if p.val > q.val:
            p, q = q, p
            
        # Check if p and q are on different sides of root
        # If yes, then return root
        if p.val <= root.val <= q.val:
            return root
        # Otherwise, recursively use this func on 
        # either left/right side of the root
        elif q.val <= root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        else:
            return self.lowestCommonAncestor(root.right, p, q)



0276. Paint Fence



0621. Task Scheduler
       


Day 114, 10/03/2020 Tue



Day 115, 10/04/2020 Wed

1640. Check Array Formation Through Concatenation

class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        '''
        Determine if arr can be formed by concatenating arrays in pieces.
        
            -types:    arr (List[int])
                    pieces (List[List[int]])
            -rtype: bool
        '''
        # An indictor to determine if such an ele in arr can be found in pieces
        found = True
        
        # Loop pieces and find if any piece can be found in arr
        # If not, the return False
        while pieces and found:
            found = False
            for i in range(len(arr)):
                if pieces[-1][0] == arr[i]:
                    found = True
                    if arr[i:i+len(pieces[-1])] != pieces[-1]:
                        print(arr[i:i+len(pieces[-1])] == pieces[-1])
                        return False
            pieces.pop()
        
        # Return True if all pieces can be found in arr, otherwise, False. 
        return True if found else False
        
        

1641. Count Sorted Vowel Strings



0033. Search in Rotated Sorted Array

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        '''
        Find index of target in nums, where nums might be rotated beforehand.
        
            -types:   nums (List[int)
                    target (int)
            -rtype: int
        '''
        import bisect
        # Case when only 1 ele in nums
        if nums[0] == nums[-1]:
            return 0 if nums[0] == target else -1

        # Case when nums is sorted and target is out of range of nums,
        # then return -1
        elif nums[0] < nums[-1] and (target > nums[-1] or target < nums[0]):
            return -1
        
        # Case when nums is sorted, then do a binary search to find if ele of 
        # that index is target
        elif nums[0] < nums[-1]:
            index = bisect.bisect_left(nums, target)
            return index if nums[index] == target else -1
        
        # Case when nums is not sorted, and target > nums[-1] and target < nums[0],
        # then just return -1
        elif target > nums[-1] and target < nums[0]:
            return -1
            
        # Else, find the original pivot,
        # and find which part target could be in and use binart search to find if target is in nums            
        elif target <= nums[-1]:
            pivot_index = nums.index(min(nums))
            index = bisect.bisect_left(nums[pivot_index:], target)
            return index+pivot_index if nums[index+pivot_index] == target else -1
        elif target >= nums[0]:
            pivot_index = nums.index(max(nums))
            index = bisect.bisect_left(nums[:pivot_index], target)
            return index if nums[index] == target else -1



Day 116, 10/05/2020 Thu


0160. Intersection of Two Linked Lists

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        '''
        Find the node at which the intersection of two singly linked lists begins
        
            -types: headA (Node)
                    headA (Node)
            -rtype: Node
        '''
        # Case when either one is null
        if not (headA and headB):
            return None
        
        # Define two pointer nodes starting from A (pA) and B (pB)
        pA, pB = headA, headB
        
        # Loop both pA and pB
        # If pA/pB fully looped, then switch it to pB/pA, and let switched + 0.5
        # when both pA/pB fully looped.
        # If switched and pA/pB fully looped again (switched > 1) but still no intersection nodes
        # found, then return None. Else, return the intersection node.
        switched = 0
        while switched <= 1:
            if not pA:
                switched += 0.5
                pA = headB
            elif not pB:
                switched += 0.5
                pB = headA
            elif pA != pB:
                pA, pB = pA.next, pB.next
            else:
                return pA
        return None



0767. Reorganize String
     


0957. Prison Cells After N Days

class Solution:
    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:
        '''
        Find the state of cells after N days.
        
            -types: cells (List[int])
                        N (int)
            -rtype: List[int]
        '''
        for x in range(N):
            old_cells = cells
            cells = [old_cells[0]] + [1 if old_cells[i-1] == old_cells[i+1] else 0 for i in range(1, 7)] + [old_cells[-1]]
        return cells



Day 117, 10/06/2020 Fri

0993. Cousins in Binary Tree


Day 118, 10/07/2020 Sat
Day 119, 10/08/2020 Sun


Day 120, 11/09/2020 Mon

1252. Cells with Odd Values in a Matrix

class Solution:
    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:    
        res = [[0 for _ in range(m)] for _ in range(n)]
        for x, y in indices:
            res[x] = [1-res[x][j] for j in range(m)]
            for i in range(n):
                res[i][y] = 1-res[i][y]
        
        return sum([sum(res[i]) for i in range(n)])


Day 120, 11/09/2020 Mon
Day 121, 11/10/2020 Tue
Day 122, 11/11/2020 Wed
Day 123, 11/12/2020 Thu
Day 124, 11/13/2020 Fri
Day 125, 11/14/2020 Sat
Day 126, 11/15/2020 Sun
Day 127, 11/16/2020 Mon
Day 128, 11/17/2020 Tue
Day 129, 11/18/2020 Wed
Day 130, 11/19/2020 Thu
Day 131, 11/20/2020 Fri
Day 132, 11/21/2020 Sat
Day 133, 11/22/2020 Sun
Day 134, 11/23/2020 Mon
Day 135, 11/24/2020 Tue
Day 136, 11/25/2020 Wed
Day 137, 11/26/2020 Thu
Day 138, 11/27/2020 Fri
Day 139, 11/28/2020 Sat
Day 140, 11/29/2020 Sun



Day 141, 11/30/2020 Mon

0647. Palindromic Substrings

class Solution:
    def countSubstrings(self, s: str) -> int:
        '''
        Find how many palindromic substrings in s.
        
            -type : s (str)
            -rtype: int 
        '''
        # Initiate result, res, as length of s, since
        # every char in s is palindromic
        res = l = len(s)
        
        # Check palindromic substrings with odd length and length > 1
        # Loop from the 1st index (0-indexed). Check if chars with same
        # distance to current char are equal
        for i in range(1, l-1):
            isPalindromic = True
            currDist = 1
            furthestDist = min(i, l-1-i) 
            
            while isPalindromic and currDist <= furthestDist:
                isPalindromic = s[i-currDist] == s[i+currDist]
                res += 1*isPalindromic
                currDist += 1
               
        # Check palindromic substrings with even length and length > 1
        # Loop from index 0. Check if the next char is equal to current char.
        # If yes, check the left char with same distance to current char and
        # the right char with same distance to the next char are equal
        for i in range(l-1):
            isPalindromic = True
            currDist = 1
            furthestDist = min(i, l-1-i-1) 
            
            if s[i] == s[i+1]:
                res += 1
                while isPalindromic and currDist <= furthestDist:
                    isPalindromic = s[i-currDist] == s[i+1+currDist]
                    res += 1*isPalindromic
                    currDist += 1
        
        return res
       

The Skyline Problem



Day 142, 12/01/2020 Tue



Day 143, 12/02/2020 Wed

Shortest Word Distance

class Solution:
    def shortestDistance(self, words: List[str], word1: str, word2: str) -> int:
        '''
        Find the shortest distance btw word1 and word2
        
            -types: words (List[str])
                    word1 (str)
                    word2 (str)
            -rtype: int
        '''
        index1 = index2 = None
        res = len(words)
        
        for i in range(len(words)):
            if words[i] == word1:
                index1 = i
            elif words[i] == word2:
                index2 = i
            
            if index1 != None and index2 != None:
                res = min(res, abs(index2 - index1))
        return res



Linked List Random Node

class Solution:

    def __init__(self, head: ListNode):
        """
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """
        self.head = head
        self.l = 0
        while head:
            self.l += 1
            head = head.next
        

    def getRandom(self) -> int:
        """
        Returns a random node's value.
        """
        import random
        r = random.randint(1, self.l)

        temp = self.head
        res = temp.val
        i = 1
        while i < r:
            temp = temp.next
            res = temp.val
            
            i += 1
        return res



0152. Maximum Product Subarray



Day 144, 12/03/2020 Thu

0039. Combination Sum   

0624. Maximum Distance in Arrays

class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        currMin = min(arrays[0])
        currMax = max(arrays[1])
        res = currMax - currMin
        
        for i in range(2, len(arrays)):
            res = max(currMax - min(arrays[i]), -currMin + max(arrays[i]), res)
            
            if max(arrays[i]) > currMax:
                currMax = max(arrays[i])
            elif currMin > min(arrays[i]):
                currMin = min(arrays[i])
        
        currMin = min(arrays[1])
        currMax = max(arrays[0])
        res = max(res, currMax - currMin)
        print(currMin, currMax)
        for i in range(2, len(arrays)):
            res = max(currMax - min(arrays[i]), -currMin + max(arrays[i]), res)
            
            if max(arrays[i]) > currMax:
                currMax = max(arrays[i])
            elif currMin > min(arrays[i]):
                currMin = min(arrays[i])
        
        return res



Day 145, 12/04/2020 Fri

The kth Factor of n

class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        '''
        Find the kth factor in this list or return -1 if n has less than k factors.
        
            -types: n (int)
                    k (int)
            -rtype: int
        '''
        # Find all factors of n by looping from 1 to n
        # Once the pointer == k, return current factor
        # If after looping all n numbers, k > pointer, return -1 
        if k == 1:
            return 1
        
        nth_factor = curr_factor = 1
        for i in range(2, n+1):
            if n%i == 0:
                nth_factor += 1
                curr_factor = i
            
            if k == nth_factor:
                return curr_factor 
        
        return -1



1041. Robot Bounded In Circle



Day 146, 12/05/2020 Sat


Day 147, 12/06/2020 Sun

class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        

0086. Partition Listclass Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        # Initiate result, res (a linked list), to gather all nodes
        # with val < x in the original relative order  before seeing
        # the first Node with val >= x
        res = head if head and head.val < x else None
        res0 = res
        head = head.next if head and res else head
        
        # Gather all nodes with val < x before observing
        # any node that has val >= x
        while head and head.val < x:
            res.next = head       
            res = res.next
            head = head.next
        
        
        # Loop the remaining part
        # If node has val >= x, then move to next nodes
        # until a node, n, has val < x is found and then 
        # append n to res and append other part to n
        # Append remaining parts if no node has val < x
        temp = head
        while temp and temp.next:
            if temp.next.val >= x:
                temp = temp.next
            elif temp.next.val < x and res:
                res.next = temp.next
                res = res.next
                temp.next = temp.next.next
            else:
                res = temp.next
                res0 = res
                temp.next = temp.next.next

        print()
        if res:
            res.next = head
        if not res and head:
            return head
        
        return res0



Day 148, 12/07/2020 Mon

0059. Spiral Matrix II

class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        '''
        Generate an n x n matrix filled with elements from 1 to n^2 in spiral (clockwise) order.
        
            -type : n (int)
            -rtype: List[List[int]]
        '''
        # Initiate result, res
        res = [[None for _ in range(n)] for _ in range(n)]
        
        # Define some metrics when creating the spiral matrix
        totalNumToFill = n  # Total number of elements to fill in row/column based on current status
        currNumToFill = n   # Current number of elements to fill in current row/column
        timesLeft = 1       # Number of total times left to before decrementing totalNumToFill
        direction = 0       # Direction to go: 0 (right), 1 (down), 2 (left), 3 (up). Start with right.
        i = j = 0           # Pointers (i: row, j: column) to indicate coordinates of current position in res
        
        # Loop the matrix (res) in a spiral order
        for x in range(n*n):
            # Assign new value to current position
            res[i][j] = x + 1
            # Decrement numToFill
            currNumToFill -= 1
            
            # Determine next location
            if direction == 0 and currNumToFill:
                j += 1
            elif direction == 0 and currNumToFill == 0:
                i += 1
                direction = 1
            elif direction == 1 and currNumToFill:
                i += 1
            elif direction == 1 and currNumToFill == 0:
                j -= 1
                direction = 2
            elif direction == 2 and currNumToFill:
                j -= 1
            elif direction == 2 and currNumToFill == 0:
                i -= 1 
                direction = 3
            elif direction == 3 and currNumToFill:
                i -= 1
            elif direction == 3 and currNumToFill == 0:
                j += 1 
                direction = 0
            
            # Check if need to update currNumToFill and totalNumToFill
            if currNumToFill == 0:
                timesLeft -= 1
                
                if timesLeft == 0:
                    timesLeft = 2
                    totalNumToFill -= 1
                currNumToFill = totalNumToFill

        return res



1046. Last Stone Weight

0399. Evaluate Division



Day 149, 12/08/2020 Tue
Day 150, 12/09/2020 Wed
Day 151, 12/10/2020 Thu
Day 152, 12/11/2020 Fri
Day 153, 12/12/2020 Sat
Day 154, 12/13/2020 Sun
Day 155, 12/14/2020 Mon
Day 156, 12/15/2020 Tue
Day 157, 12/16/2020 Wed
Day 158, 12/17/2020 Thu
Day 159, 12/18/2020 Fri
Day 160, 12/19/2020 Sat
Day 161, 12/20/2020 Sun
Day 162, 12/21/2020 Mon
Day 163, 12/22/2020 Tue
Day 164, 12/23/2020 Wed
Day 165, 12/24/2020 Thu
Day 166, 12/25/2020 Fri
Day 167, 12/26/2020 Sat
Day 168, 12/27/2020 Sun



Day 169, 12/28/2020 Mon

1502. Can Make Arithmetic Progression From Sequence

class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        '''
        Determine if arr can be rearranged to form an arithmetic progression.
        
            -type : arr (List[int])
            -rtype: bool
        '''
        # Sort arr
        arr.sort()
        
        # Determine if rearranged an arithmetic progression.
        return all([abs(arr[i] - arr[i-1]) == abs(arr[0] - arr[1]) for i in range(1, len(arr))])
        


0721. Accounts Merge

Challenge. Reach a Number



Day 170, 12/29/2020 Tue


Day 171, 12/30/2020 Wed

Challenge

Longest Substring with At Most K Distinct Characters

class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        '''
        Find the length of the longest substring with at most K distinct chars.
        
            -types: s (str)
                    k (int)
            -rtype: int
        '''
        # Special case when k is 0
        if k == 0:
            return 0
        
        max_len = curr_len = 1
        num_of_distinct = 1
        distinct_chars = {s[0]: 1}
        i, j, l = 0, 1, len(s)
        
        # Loop s.
        # If adding current char is not making num_of_distinct > k, then curr_len + 1 and j + 1
        # Else, remove the first char of the substring and increment the substring start index
        while j < l:
            if num_of_distinct < k:
                if s[j] in distinct_chars:
                    distinct_chars[s[j]] += 1
                else:
                    distinct_chars[s[j]] = 1
                    num_of_distinct += 1
                curr_len += 1
                j += 1
            
            elif s[j] in distinct_chars:
                distinct_chars[s[j]] += 1
                curr_len += 1
                j += 1
                
            else:
                distinct_chars[s[i]] -= 1
                if distinct_chars[s[i]] == 0:
                    num_of_distinct -=  1
                    del distinct_chars[s[i]]
                i += 1
                curr_len -= 1
            
            max_len = max(max_len, curr_len)
            print(max_len, curr_len, num_of_distinct)
        return max_len



1033. Moving Stones Until Consecutive

class Solution:
    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
        '''
        Find the min and maxm number of moves that can make positions consecutive
        
            -types: a (int)
                    b (int)
                    c (int)
            -rtype: List[int]
        '''
        # Create a list to make a, b and c sorted
        l = sorted([a, b, c])
        
        # Case when l is consective
        if l[0] + 1 == l[1] and l[1] + 1 == l[2]:
            return [0, 0]
        
        # Case when delta btw one neighbor is 1 and the other is 2
        if (l[0] + 1 == l[1] and l[1] + 2 == l[2]) or (l[0] + 2 == l[1] and l[1] + 1 == l[2]):
            return [1, 1]

        # Case when delta btw 2 neighbors is 2
        if l[0] + 2 == l[1] and l[1] + 2 == l[2]:
            return [1, 2]

        # Case when there is only 1 neighbored pair that delta = 1
        if l[0] + 1 == l[1]:
            return [1, l[2]-l[1]-1]
        if l[1] + 1 == l[2]:
            return [1, l[1]-l[0]-1]
            
        # Case when there is only 1 neighbored pair that delta = 2
        if l[0] + 2 == l[1]:
            return [1, l[2]-l[1]]
        if l[1] + 2 == l[2]:
            return [1, l[1]-l[0]]
            
        # Other cases
        return [2, l[1]-l[0]-1+l[2]-l[1]-1]



Day 172, 12/31/2020 Thu
Day 173, 01/01/2021 Fri
Day 174, 01/02/2021 Sat
Day 175, 01/03/2021 Sun


Day 176, 01/04/2021 Mon

0050. Pow(x, n)

class Solution:
    def myPow(self, x: float, n: int) -> float:
        '''
        Calculates x raised to the power n 
        
            -types: x (float)
                    n (int)
            -rtype: float
        '''
        from functools import reduce
        # Case when x is 0 or 1
        if x == 0 or x == 1:
            return x
        
        # Case when x is -1
        if x == -1:
            return (-1) ** (abs(n)%2)
        
        # Case when n is 0
        if n == 0:
            return 1.0000     
        
        res = 1
        cnt = 0
        # Case when n > 0
        if n > 0:
            while cnt < abs(n) and abs(round(res, 6)) > 0:
                res *= x
                cnt += 1

        # Case when n < 0
        if n < 0:
            while cnt < abs(n) and abs(round(res, 6)) > 0:
                res *= 1/x
                cnt += 1
            
        return round(res, 6)



Day 177, 01/05/2021 Tue



Day 178, 01/06/2021 Wed

1048. Longest String Chain

Day 179, 01/07/2021 Thu
Day 180, 01/08/2021 Fri
Day 181, 01/09/2021 Sat
Day 182, 01/10/2021 Sun
Day 183, 01/11/2021 Mon
Day 184, 01/12/2021 Tue



Day 185, 01/13/2021 Wed

Boats to Save People   



0637. Average of Levels in Binary Tree

class Solution:
    def averageOfLevels(self, root: TreeNode) -> List[float]:
        '''
        Find the average value of the nodes on each level of root.
        
            -type : root (TreeNode)
            -rtype: List[float]
        '''
        if not root: return []
        
        stack = [root]
        storage = []
        currSum = currCnt = 0
        res = []
        
        # Loop one level and find all values and take average to append to res 
        while stack:
            while stack:
                temp = stack.pop()
                      
                currSum += temp.val
                currCnt += 1
                
                # Only include non-empty children
                if temp.left:
                    storage.append(temp.left)
                if temp.right:
                    storage.append(temp.right)  
            
            # Calculating average for this level
            if currCnt:
                res.append(currSum/currCnt)
            
            # Reset values
            stack = storage
            storage = []
            currSum = currCnt = 0
            
        return res 



0139. Word Break



Day 186, 01/14/2021 Thu

Minimum Operations to Reduce X to Zero

0276. Paint Fence

1423. Maximum Points You Can Obtain from Cards

class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        '''
        Find the maximum score you can obtain

            -types: cardPoints (List[int])
                             k (int)
            -rtype: int
        '''
        l = len(cardPoints)
        
        # Special cases
        # 1. l == k
        if l == k:
            return sum(cardPoints)
        # 2. k is 1
        if k == 1:
            return max(cardPoints[0], cardPoints[-1])
        
        # Initiate two pointers to loop cardPoints from both ends, with assuming to start with
        # taking k cards from the left, and then removing rightmost card on the left part and taking
        # one card from the right part, until no cards left in the left part.
        # In this process, dynamically recording max points.
        i, j = k-1, l-1
        maxPoints = currPoints = sum(cardPoints[:k])
        while i >-1:
            currPoints = currPoints - cardPoints[i] + cardPoints[j]
            i -= 1
            j -= 1
            maxPoints = max(maxPoints, currPoints)
        
        return maxPoints
            
        
        


Day 187, 01/15/2021 Fri

Get Maximum in Generated Array

class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        '''
        Find the max of th generated array
        
            -type : n (int)
            -rtype: int
        '''
        # Cases when n is 0
        if n == 0:
            return 0
        
        # Initiate the result array, and a variable t remember max
        res = [0]*(n + 1)
        res[1] = 1
        maxNum = 1
        
        for i in range(2, n+1):
            res[i] = res[i//2] if i%2 == 0 else res[(i-1)//2] + res[(i-1)//2+1]
            maxNum = max(maxNum, res[i])
        
        return maxNum



1708. Largest Subarray Length K

class Solution:
    def largestSubarray(self, nums: List[int], k: int) -> List[int]:
        '''
        Find the largest subarray of nums of length k
           
            -types: nums (List[int])
                       k (int)
            -rtype: List[int]
        '''
        # Since elements in nums are all distinct, just find where max of
        # nums[:len(nums)-k+1] and the result array will be nums[maxPos:(maxPos+k)]
        maxPos = max(nums[:len(nums)-k+1])
        maxPos = nums.index(maxPos)
        
        return nums[maxPos:(maxPos+k)]



0987. Vertical Order Traversal of a Binary Tree

1428. Leftmost Column with at Least a One



Day 188, 01/16/2021 Sat
Day 189, 01/17/2021 Sun
Day 190, 01/18/2021 Mon
Day 191, 01/19/2021 Tue
Day 192, 01/20/2021 Wed

Day 193, 01/21/2021 Thu

0523. Continuous Subarray Sum

1583. Count Unhappy Friends

1673. Find the Most Competitive Subsequence



Day 194, 01/22/2021 Fri

One Edit Distance

class Solution:
    def isOneEditDistance(self, s: str, t: str) -> bool:
        '''
        Determine if s and t are both one edit distance apart, 
           
           -types: s (str)
                   t (str)
           -rtype: bool
        '''
        # Special case if both s and t are empty, then return false
        if not (s or t):
            return False
        
        # Keep removing chars one by one from the start of both s and t as long as
        # current elements of s and t are the same
        while s and t and s[0] == t[0]:
            s = s[1:]
            t = t[1:]
        
        # Keep removing chars one by one from the end of both s and t as long as
        # current elements of s and t are the same
        while s and t and s[-1] == t[-1]:
            s = s[:-1]
            t = t[:-1]
        
        # Determine if both s and t have length = 1, or just one has length = 1
        return (len(s) == 1 and len(t) == 1) or (len(s) == 0 and len(t) == 1) or (len(s) == 1 and len(t) == 0)



0539.Minimum Time Difference  

class Solution:
    def findMinDifference(self, timePoints: List[str]) -> int:
        '''
        Find the min time difference between any two time elements in timePoints
        
            -type : timePoints (List[str])
            -rtype: int
        '''
        # Sort timePoints
        timePoints.sort()
        
        # Define a function, diffMin, to determine time difference, in minute, between two time-points
        def diffMin(t1: str, t2: str) -> int:
            '''
            Find time difference (in minute) between t1 and t2
            
                -types: t1 (str)
                        t2 (str)
                -rtype: int
            '''
            # Split t1 and t2 to lists in format of ["HH", "MM"]
            t1 = t1.split(':')
            t2 = t2.split(':')
            
            # Find difference of HH and MM part
            h = int(t1[0]) - int(t2[0])
            m = int(t1[1]) - int(t2[1])
            
            # Convert h to positive and then m to minute diff btw t1 and t2
            h = 24 + h if h < 0 else h
            m = abs(60*h + m)
            
            # return min of m and 24*60-m
            return min(m, 24*60-m)
            
        # Loop timePoints and find min diff btw any two time-points
        res = 60*24
        for i in range(len(timePoints)):
            res = min(res, diffMin(timePoints[i-1], timePoints[i]))
        
        return res
        


0547. Number of Provinces

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        '''
        Find the number of provinces based on the connection board
        
            -type : isConnected (List[List[int]])
            -rtype: int
        '''
        # Create a board, visited, that has the same size as isConnected, to 
        # record positions visited
        num_of_prov = len(isConnected)
        self.visited = [False for _ in range(num_of_prov)]
        
        # Create a dictionary to record connected positions for each position
        # Loop isConnected. If a 1 is seen, record this connected position in connection
        self.connection = {}
        for i in range(num_of_prov):
            for j in range(num_of_prov):
                if i in self.connection and isConnected[i][j] :
                    self.connection[i].add(j)
                elif isConnected[i][j]:
                    self.connection[i] = set([j])

        # Initiate result, number of connected province group(s)
        res = 0

        def findAllConnected(i: int) -> None:
            '''
            Find all connected positions and mark them as visited
            
                -type : i (int)
                -rtype: None
            '''
            # Mark current position as visited
            self.visited[i] = True
            
            for x in self.connection[i]:
                if not self.visited[x] and i != x:
                    findAllConnected(x)
            return
        
        # Loop each position and mark their connected position(s)
        for i in range(num_of_prov):
            if not self.visited[i]:
                res += 1        
                findAllConnected(i)

        return res



Day 195, 01/23/2021 Sat

Day 196, 01/24/2021 Sun

Merge k Sorted Lists

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        '''
        Merge k linked-lists lists, each in ascending order) into one sorted linked-list
        
            - type: lists (List[ListNode])
            -rtype: ListNode
        '''
        # Create a dict to find frequency of nodes with different values
        d = {}
        
        for l in lists:
            while l:
                if l.val in d:
                    d[l.val] += 1
                else:
                    d[l.val] = 1
                l = l.next
        
        # Sort keys of d in ascending order, and append d[key] nodes with val = key to res0
        keys = sorted(d.keys())
        
        res0 = res = ListNode()
        
        for k in keys:
            for i in range(d[k]):
                res0.next = ListNode(k)
                res0 = res0.next
        res = res.next
        
        return res



0207. Course Schedule

0279. Perfect Squares

class Solution:
    def numSquares(self, n: int) -> int:
        '''
        Find the least number of perfect square numbers that sum to n.
        
            - type: n (int)
            -rtype: int
        '''
        # List all perfect squares <= n
        self.perfect_squares = set([x*x for x in range(1, int(n**0.5)+1)])
        
        # Case when n is already a perfect square number 
        if n in self.perfect_squares:
            return 1
        
        # Create a dp, where index = i and value = east number of 
        # perfect square numbers that sum to i.
        # If i is a perfect square, dp[i] = 1
        # Else, loop all dp[i]-x (x = a perfect square < i) and find
        # the smallest 1 + dp[i-x]
        dp = [10000]*(n+1)
        dp[1] = 1
        for i in range(2, n+1):
            if i in self.perfect_squares:
                dp[i] = 1
            else:
                for x in [p for p in self.perfect_squares if p < i]:
                    dp[i] = min(dp[i], 1 + dp[i-x])

        return dp[-1]




Day 197, 01/25/2021 Mon

Check If All 1's Are at Least Length K Places Away

class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        '''
        Check if all 1's are at least k places away from each other.
        
            -types: nums (List[int])
                       k (int)
            -rtype: bool
        '''
        # Loop nums. Every time when see a 1, record its position, pos.
        # When see next 1, check if its position i and pos < k.
        # If yes, return False. Else, assign i to pos and continue checking.
        pos = 0 if nums[0] else -1
        for i in range(1, len(nums)):
            if pos > -1 and nums[i] and i != pos and i - pos <= k: 
                return False
            
            if nums[i]:
                pos = i
                  
        return True
        
0015. 3Sum

0323. Number of Connected Components in an Undirected Graph

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        '''
        Find the number of connected components in an undirected graph.
            
            -types:     n (int)
                    edges (List[List[int]])
            -rtype: int
        '''
        # Create a dict, d, to record nodes and its conneted nodes , where key
        # = this node and value = a set of connected nodes
        d = {}
        for x, y in edges:
            if x in d:
                d[x].add(y)
            else:
                d[x] = set([y])
            
            if y in d:
                d[y].add(x)
            else:
                d[y] = set([x])

        # Create a set, visited, to record nodes visited
        visited = set()
        
        # Loop from 0 to n-1. Initiate final result = number of connected components, as res.
        # If i has been visited, then skip i and run i + 1
        # Talking about i has bot been visited:
        # 1). If i in d, put i in visited. Create a queue to hold all its connected nodes that
        #     are not visited. Keep adding unvisted connected nodes of nodes in the queue, until
        #     the queue is empty
        # 2). If i is not in d, then it means i is an isolated point, so res +1.
        res = 0
        
        for i in range(n):
            if i not in visited:
                if i in d:
                    queue = [i]
                    while queue:
                        currNode = queue.pop()
                        visited.add(currNode)
                        queue = list(d[currNode]) + queue
                        queue = [x for x in queue if x not in visited]
                res += 1

        return res



Day 198, 01/26/2021 Tue

Path With Minimum Effort




Day 199, 01/27/2021 Wed

Concatenation of Consecutive Binary Numbers

class Solution:
    def concatenatedBinary(self, n: int) -> int:
        '''
        Concatenating the binary representations of 1 to n in order and mod 10^9 + 7.
        
            - type: n (int)
            -rtype: int
        '''
        res = ''
        for x in range(1, n+1):
            res += bin(x)[2:]
        res = int(res, 2)%(10**9 + 7)
        return res



0152. Maximum Product Subarray

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        '''
        Find  the largest product of contiguous subarrays within nums.
        
            - type: nums (List[int])
            -rtype: int
        '''
        # Create two arrays, Max and Min, to record max and min 
        # cumulative product before current element (inclusive).
        # Initiate 1st ele for both as nums[0].
        Max = [None for _ in range(len(nums))]
        Min = [None for _ in range(len(nums))]
        Max[0] = [nums[0]]
        Min[0] = [nums[0]]
        
        # Loop nums for the 2nd ele.
        # Determine current Max and Min at position i based on product of
        # current ele with Max[i-1]/Min[-1] or nums[i] itself, since
        # max/min can change with sign or multiplying by 0.
        # The max of Max will then be the final result.
        for i in range(1, len(nums)):
            Max[i] = max(nums[i]*Max[i-1], nums[i]*Min[i-1], nums[i])
            Min[i] = min(nums[i]*Max[i-1], nums[i]*Min[i-1], nums[i])
        
        return max(Max)



0200. Number of Islands   

class Solution:  
    # Define a function, dfs, to search all connected cells in grid of 
    # current cell and mark them as visited.
    def dfs(self, x: int, y: int, h: int, w: int, grid: List[List[str]]) -> None:    
        '''
        Search all connected cells in grid for the cell at position (i, j) and mark
        them as visited. Height and width of grid are h and w

            -types:    x (int)
                       y (int)
                       h (int)
                       w (int)
                    grid (List[List[str]])
            -rtype: None
        '''
        if 0 <= x < h and 0 <= y < w and grid[x][y] == '1' and not self.visited[x][y]:
            self.visited[x][y] = 1
            self.dfs(x+1, y, h, w, grid)
            self.dfs(x, y+1, h, w, grid)
            self.dfs(x-1, y, h, w, grid)
            self.dfs(x, y-1, h, w, grid)

    def numIslands(self, grid: List[List[str]]) -> int:
        '''
        Find total number of island in grid.
        
            - type: grid (List[List[str]])
            -rtype: int
        '''
        h, w = len(grid), len(grid[0])
        # Create a array of arrays, vistied, with same size as grid
        # to record if a cell in grid is visited. Set each ele as 0 initially.
        self.visited = [[0 for _ in range(w)] for _ in range(h)]
        
        # Loop grid. Once a cell has value = 1, mark it as visited and visit all its   
        # neigbors, until none of them is 1 or all are visited.
        res = 0
        for i in range(h):
            for j in range(w):
                if grid[i][j] == '1' and self.visited[i][j] == 0:
                    res += 1
                    self.dfs(i, j, h, w, grid)
        return res



Day 200, 01/28/2021 Thu

Smallest String With A Given Numeric Value

class Solution:
    def getSmallestString(self, n: int, k: int) -> str:
        '''
        Find the lexicographically smallest string with length equal to n and numeric value equal to k.
        
            -types:   n (int)
                      k (int)
            -rtype: str
        '''
        # Initiate res.
        res = ''
        
        # Determine how many 'a' we can have. 
        while k - 1 <= (n-1) * 26:
            res += 'a'
            k -= 1
            n -= 1
        
        # For remaining k, determine min number of 'z' we need,
        # and then convert the remaining value to the letter
        # btw 'a's and 'z's
        res += chr(k - 26*(n-1) + 96) + (n-1)*'z'
        
        return res



0437. Path Sum III

1197. Minimum Knight Moves



Day 201, 01/29/2021 Fri

Number Of Corner Rectangles

Vertical Order Traversal of a Binary Tree

class Solution:
    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
        '''
        Find vertical order traversal of root.
        
            -type : root (TreeNode)
            -rtype: List[List[int]]
        '''
        # Case when root is empty
        if not root:
            return []
        
        # Assume coordinates of root is (0, 0).
        # Traverse the root, once go left, x-coordinate - 1;
        # once go right, x-coordinate + 1.
        # Onc go down 1 level, y-coordinate + 1.
        # Use a dict, d, with key = x-cor and val = another dict d0, to record nodes
        # traversed.
        # For d0, key = y-cor and value = a sorted list of values
        d = {}
        nodes_in_current_level = [[root, 0, 0]]
        
        while nodes_in_current_level:
            child_nodes = []
            while nodes_in_current_level:
                curr_node = nodes_in_current_level.pop()
                if curr_node[1] in d:
                    if curr_node[2] in d[curr_node[1]]:
                        d[curr_node[1]][curr_node[2]].append(curr_node[0].val)
                    else:
                        d[curr_node[1]][curr_node[2]] = [curr_node[0].val]
                else:
                    d[curr_node[1]] = {}
                    d[curr_node[1]][curr_node[2]] = [curr_node[0].val]
                
                if curr_node[0].left:
                    child_nodes.append([curr_node[0].left, curr_node[1] - 1, curr_node[2] + 1])
                if curr_node[0].right:
                    child_nodes.append([curr_node[0].right, curr_node[1] + 1, curr_node[2] + 1])
            nodes_in_current_level = child_nodes
        
        # Combine values under same x and y coordinates
        res = []
        for x in sorted(d):
            temp = []
            for y in sorted(d[x]):
                temp.extend(sorted(d[x][y])) 
            res.append(temp)

        return res



0543. Diameter of Binary Tree

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:



Day 202, 01/30/2021 Sat
Day 203, 01/31/2021 Sun

Day 204, 02/01/2021 Mon

Squirrel Simulation

class Solution:
    def minDistance(self, height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:
        

0300. Longest Increasing Subsequence

0735. Asteroid Collision

class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        '''
        Find out the state of the asteroids after all collisions.
            
            - type: asteroids (List[int])
            -rtype: List[int]
        '''
        # Create result list, res
        # Loop asteroids. 
        # If res is empty or last ele in res has the same sign as current asteroid,
        # append current asteroid to res.
        # If the last ele in res > 0 (larger size) and current asteroid < 0 (smaller size),
        # smash current asteroid and move to next asteriod.
        # If the last ele in res > 0 (smaller size) and current asteroid < 0 (larger size),
        # smash last ele in res (note if res will be empty) and keep comparing the last ele in res.
        # If last ele in res > 0 and current asteroid < 0 and they have same size, 
        # move to next asteriod and pop last ele in res.
        # If last ele in res < 0 and current asteroid > 0, append current asteroid to res.
        res = []
        i, l = 0, len(asteroids)
        while i < l:
            if res:
                while i < l and res and (res[-1]*asteroids[i] > 0 or res[-1] < 0 and asteroids[i] > 0):
                    res.append(asteroids[i])
                    i += 1
                while i < l and res and res[-1] > 0 and asteroids[i] < 0 and abs(res[-1]) > abs(asteroids[i]):
                    i += 1
                while i < l and res and res[-1] > 0 and asteroids[i] < 0 and abs(res[-1]) < abs(asteroids[i]):
                    res.pop()
                while i < l and res and res[-1] > 0 and asteroids[i] < 0 and abs(res[-1]) == abs(asteroids[i]):
                    res.pop()
                    i += 1         
            else:
                res.append(asteroids[i])
                i += 1
 
        return res



Day 205, 02/02/2021 Tue

Trim a Binary Search Tree
class Solution:
    def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
        '''
        Find the tree with any values out of [low, high] trimmed.
        
            -types: root (TreeNode)
                     low (int)
                    high (int)
            -rtype: TreeNode
        '''
        # Case when root is empty
        if not root: return None
        
        # Case when root is not empty but itself < low or itself > high
        while root.val < low or root.val > high:  
            if root.val < low:
                root = root.right
            if root.val > high: 
                root = root.left    
        
        # Trim left and right branches
        while root.left and root.left.val < low:
            root.left = root.left.right
        root.left = self.trimBST(root.left, low, high)
        
        while root.right and root.right.val > high:
            root.right = root.right.left
        root.right = self.trimBST(root.right, low, high)
        
        return root



Day 206, 02/03/2021 Wed

Day 207, 02/04/2021 Thu


0286. Walls and Gates

class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        '''
        Fill each empty room with the distance to its nearest gate.
        
            -type : rooms (List[List[int]])
            -rtype: None
        '''
        # Find height and width of rooms
        h, w = len(rooms), len(rooms[0])
        
        # self.visited = [[0 if rooms[x][y] == 0 else 1 for y in range(w)] for x in range(h)]
        
        # Define a fucntion to search and change values in rooms
        def changeAllConnectEmptyCells(i: int, j: int, h: int, w: int, rooms: List[List[int]]) -> None:
            if 0 <= i < h and 0 <= j < w and rooms[i][j] not in [0, -1]:
                old_val = rooms[i][j]
                rooms[i][j] = min(rooms[i][j], rooms[i-1][j]+1) if i-1 > -1 and rooms[i-1][j] != -1 else rooms[i][j]
                rooms[i][j] = min(rooms[i][j], rooms[i+1][j]+1) if i+1 < h  and rooms[i+1][j] != -1 else rooms[i][j]
                rooms[i][j] = min(rooms[i][j], rooms[i][j-1]+1) if j-1 > -1  and rooms[i][j-1] != -1 else rooms[i][j]
                rooms[i][j] = min(rooms[i][j], rooms[i][j+1]+1) if j+1 < w  and rooms[i][j+1] != -1 else rooms[i][j]
                
                if rooms[i][j] != old_val:
                    changeAllConnectEmptyCells(i-1, j, h, w, rooms)
                    changeAllConnectEmptyCells(i+1, j, h, w, rooms)
                    changeAllConnectEmptyCells(i, j-1, h, w, rooms)
                    changeAllConnectEmptyCells(i, j+1, h, w, rooms)
        
        
        # Loop rooms. If find a gate, go to every 4-directional cells, and their adjacent 
        # cells. If the cell is empty, assign a value to it based on current search.
        # If it is not empty (neither a wall nor a gate), replace it with min of its current value 
        # and current search + 1.
        # Stop when adjacent cells are walls or the value itself is already the shortest dist
        # to a gate
        for i in range(h):
            for j in range(w):
                if rooms[i][j] == 0:  # A gate
                    changeAllConnectEmptyCells(i-1, j, h, w, rooms)
                    changeAllConnectEmptyCells(i+1, j, h, w, rooms)
                    changeAllConnectEmptyCells(i, j-1, h, w, rooms)
                    changeAllConnectEmptyCells(i, j+1, h, w, rooms)
                    
        
        


0695. Max Area of Island

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        '''
        Find the maximum area of an island in grid
        
            -type : grid (List[List[int]])
            -rtype: int
        '''
        # Initiate final result, max area
        max_area = 0
        
        # Find height and width of grid
        h = len(grid)
        w = len(grid[0]) if h else 0
        
        # Create a reference grid, visited, with same
        # size as grid, to indicate if a grid is 
        # visited or not
        self.visited = [[0 for _ in range(w)] for _ in range(h)]
        
        
        # Define a function to search all in/directly connected cells
        def totalDirected(i: int, j: int, h: int, w: int, grid: List[List[int]]) -> int:
            '''
            Find all in/directly connected cells
            
                -types:    i (int)
                           j (int)
                           w (int)
                           i (int)
                        grid (List[List[int]])
                -rtype: int
            '''
            # Keep searching all 4-directional cells
            if grid[i][j] and not self.visited[i][j]:
                self.visited[i][j] = 1
                res = 1
                
                res += totalDirected(i - 1, j, h, w, grid) if i - 1 > -1 else 0
                res += totalDirected(i + 1, j, h, w, grid) if i + 1 < h else 0
                res += totalDirected(i, j - 1, h, w, grid) if j - 1 > -1 else 0
                res += totalDirected(i, j + 1, h, w, grid) if j + 1 < w else 0
                
                return res
            return 0
            
        # Loop grid cell by cell, and if see a 1, find all in/directly 
        # connect 1's and calculate their sum as the area.
        # If area > max area, replace max area with area.
        for i in range(h):
            for j in range(w):
                if grid[i][j] and not self.visited[i][j]:
                    max_area = max(max_area, totalDirected(i, j, h, w, grid))
        
        return max_area


    
1048. Longest String Chain



Day 208, 02/05/2021 Fri

Day 209, 02/06/2021 Sat

Day 210, 02/07/2021 Sun

Shortest Distance to a Character

class Solution:
    def shortestToChar(self, s: str, c: str) -> List[int]:
        '''
        Find the shortest distance from s[i] to c
        
            -types: s (str)
                    c (str)
            -rtype: List[int]
        '''
        # Loop s and find all indices of eles = c
        indices = [i for i in range(len(s)) if s[i] == c]
        
        # Find indices of c in s. And find closest distance for each ele to c
        answer = [abs(i-indices[0]) for i in range(indices[0]+1)]
        for i in range(1, len(indices)):
            mid = (indices[i] + indices[i-1]) // 2
            answer.extend([abs(j-indices[i-1]) for j in range(indices[i-1]+1, mid+1)])
            answer.extend([abs(j-indices[i]) for j in range(mid+1, indices[i]+1)])
        
        # Find distances for all ele after the last occurence of c
        anwer.extend([abs(i-indices[-1]) for i in range(indices[-1]+1, len(s))])
        
        return answer
 


Day 211, 02/08/2021 Mon

Number of Distinct Islands

class Solution:
    def numDistinctIslands(self, grid: List[List[int]]) -> int:
        '''
        Find number of unique islands in grid
        
            -type : grid (List[List[int]])
            -rtype: int
        '''
        # Find height and width of grid
        h, w = len(grid), len(grid[0])
        
        # Use another list of list, visited, as a reference
        # to record if a cell in grid is visited or not
        self.visited = [[0 for _ in range(w)] for _ in range(h)]
        
        # Create a set, pattern, to record patterns of islands
        # we have seen.
        pattern = set()
        
        
        # Define a function to depict the current island we find, and mark all found island
        # cells as visited. 
        # Use a string to depict the island
        def depictIsland(i: int, j: int, x: int, y: int, h: int, w: int, grid: List[List[int]]) -> str:
            '''
            Depict the current island found
            
                -types:    i (int)
                           j (int)
                           x (int)
                           y (int)
                           h (int)
                           w (int)
                        grid (List[List[int]])
                -rtype: str
            '''
            # Mark the cell as visisted
            self.visited[i][j] = 1
            
            # Initiate result. Use coordinates to string of current cell as ID
            res = str(i-x)+str(j-y)
            
            # Keep visiting all adjacent tcells,
            # until none of them is an island cell / visited
            if i + 1 < h and grid[i+1][j] and not self.visited[i+1][j]:
                res +=  depictIsland(i+1, j, x, y, h, w, grid)
            if j + 1 < w and grid[i][j+1] and not self.visited[i][j+1]:
                res +=  depictIsland(i, j+1, x, y, h, w, grid)
            if i - 1 > -1 and grid[i-1][j] and not self.visited[i-1][j]:
                res +=  depictIsland(i-1, j, x, y, h, w, grid)
            if j - 1 > -1 and grid[i][j-1] and not self.visited[i][j-1]:
                res +=  depictIsland(i, j-1, x, y, h, w, grid)
            
            return res
        
        # Loop grid. If current cell is a 1 and not visited, find all its connected cells
        # and mark them as visted, and record  the pattern of the island
        num_of_distinct_islands = 0
        for i in range(h):
            for j in range(w):
                if grid[i][j] and not self.visited[i][j]:
                    current_island = depictIsland(i, j, i, j, h, w, grid)
                    num_of_distinct_islands += current_island not in pattern
                    pattern.add(current_island)
        return num_of_distinct_islands



0938. Range Sum of BST

class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        '''
        Find the sum of node values between low and high
        
            -types: root (TreeNode)
                     low (int)
                    high (int)
            -rtype: int
        '''
        # Case when root is empty
        if not root: return 0
        
        # Initiate final answer
        self.ans = 0
        
        # Case when root.val < low, then just search right part
        if root.val < low:
            self.ans += self.rangeSumBST(root.right, low, high)
        # Case when root.val > high, then just search left part
        if root.val > high:
            self.ans += self.rangeSumBST(root.left, low, high)
        # Case when root.val is between low and high, then just search both left and right
        elif low <= root.val <= high:
            self.ans += root.val
            self.ans += self.rangeSumBST(root.left, low, high) 
            self.ans += self.rangeSumBST(root.right, low, high)
             
        return self.ans



1130. Minimum Cost Tree From Leaf Values

class Solution:
    def mctFromLeafValues(self, arr: List[int]) -> int:


Day 212, 02/09/2021 Tue

Day 213, 02/10/2021 Wed
Day 214, 02/11/2021 Thu
Day 215, 02/12/2021 Fri
Day 216, 02/13/2021 Sat
Day 217, 02/14/2021 Sun

Day 218, 02/15/2021 Mon

Kill Process

class Solution:
    def killProcess(self, pid: List[int], ppid: List[int], kill: int) -> List[int]:
        '''
        Find the list of PIDs of processes that will be killed in the end
        
            -types:  pid (List[int])
                    ppid (List[int]) 
                    kill (int)
            -rtype: List[int]
        '''
        # Create dict, d, with key = ppid and values = list of pid
        d = {}
        for i in range(len(pid)):
            if ppid[i] in d:
                d[ppid[i]].append(pid[i])
            else:
                d[ppid[i]] = [pid[i]]
        
        # Check the number to kill
        # If it is not in d, then it must be a leaf. Just return
        # the number in a list format.
        if kill not in d:
            return [kill]
        
        # Otherwise, find all its children pids.
        else:
            res = [kill]
            stack = [kill]
            while stack:
                num = stack.pop()
                if num in d:
                    res.extend(d[num])
                    stack.extend(d[num])
        return res 



The K Weakest Rows in a Matrix

class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        '''
        Find the k weakest rows in the matrix ordered from the weakest to the strongest
        
            -types: mat (List[List[int]])
                      k (int)
            -rtype: List[int]
        '''
        # Find row sum in mat
        res = [sum(x) for x in mat]
        
        # Sort res based row sum, row num
        res = [[y, x] for x, y in enumerate(res)]
        res.sort()
        
        # Return first k row#
        return [x[1] for x in res[:k]]



0091. Decode Ways



Day 219, 02/16/2021 Tue

Letter Case Permutation

class Solution:
    def letterCasePermutation(self, S: str) -> List[str]:
        res = ['']
        for i in range(len(S)-1, -1, -1):
            if S[i].isalpha():
                res = [S[i].upper()+x for x in res] + [S[i].lower()+x for x in res]
            else:
                res = [S[i]+x for x in res]
        return res
    
    
    
Day 220, 02/17/2021 Wed

Container With Most Water

class Solution:
    def maxArea(self, height: List[int]) -> int:
        '''
        Find max area that any two lines forming a container that contains the most water
        
            -type : height (List[int])
            -rtype: int
        '''
        # Starting from both ends of height
        left, right = 0, len(height)-1
        
        # Moving both left and right to the center, and each time only the smaller one with
        # 1 unit. And each time find the max of current area and max area.
        max_area = 0
        while left < right:
            max_area = max(max_area, min(height[left], height[right]) * (right - left))
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        
        return max_area





Day 221, 02/18/2021 Thu

Arithmetic Slices

class Solution:
    def numberOfArithmeticSlices(self, A: List[int]) -> int:
        '''
        Find the number of arithmetic slices in A
        
            -type : A (List[int])
            -rtype: int
        '''
        # Loop A from 0 to len(A)-3, inclusive (since a slice has to have length > 2). 
        # Once see diff of i and i+i = diff of i+1 and i+2, keep incrementing i, and 
        # recording the length of this slice. Then the possible number of combination
        # = (1+n)*n//2
        i = 0
        res = 0
        l = len(A)-2
        while i < l:
            diff = A[i]-A[i+1]
            curr_l = 0
            while i < l and A[i+1]-A[i+2] == diff:
                curr_l += 1
                i += 1
            res += (1+curr_l)*curr_l//2
            i += 1 # Increment i since continuity is break 
        return res



0739. Daily Temperatures

1209. Remove All Adjacent Duplicates in String II

class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        '''
        Find s after k duplicatie removal
        
            -types: s (str)
                    k (int)
            -rtype: str
        '''
        l = len(s)
        new_l = l   # Find new length for next loop. Stop the big
                    # loop when l == new_l
        while True:
            curr_l = 1  # to record duplicates with length >= k
            i = 1       # Initiate the pointer
            ans = ''

            while i < l: 
                # Keep looking for duplicates 
                if s[i-1] == s[i]:
                    curr_l += 1
                # Duplicated breaks, update new info
                else:
                    ans += (curr_l%k)*s[i-1]
                    new_l -= (curr_l//k)*k
                    curr_l = 1
                i += 1
  
            # Determine what to append to ans
            ans += (curr_l%k)*s[i-1]
            new_l -= (curr_l//k)*k
            
            # Determine if to stop the big loop
            if l == new_l or new_l == 0:
                break
            else:
                l = new_l
            
            # Update s
            s = ans
        
        return ans



Day 222, 02/19/2021 Fri

Minimum Remove to Make Valid Parentheses



Day 223, 02/20/2021 Sat

Day 224, 02/21/2021 Sun

Broken Calculator

class Solution:
    def brokenCalc(self, X: int, Y: int) -> int:
        '''
        Find the minimum number of operations needed to display Y
        
            -types: X (int)
                    Y (int)
            -rtype: int
        '''
        # Case when X >= Y
        if X >= Y:
            return X - Y
        
        res = 0 # Initiate final answer
        
        # Keep halving Y until Y is odd, then increment Y and keep halving new Y
        # unitil Y == X. (Reverse solving)
        while Y != X:
            if Y%2 or Y < X:
                Y += 1
            else:
                Y = Y//2
            res += 1
        return res



0098. Validate Binary Search Tree

class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        '''
        Determine if root is a valid BST
        
            -type : root (TreeNode)
            -rtype: bool
        '''
        
        def canStillSearch(root: TreeNode, Min: int, Max: int) -> bool:
            '''
            Determine if a BST can still be determine if it valid
            
                -types: root (TreeNode)
                         min (int)
                         max (int)
                -rtype: bool
            '''
            # Case when root is null
            if not root: return True
            
            # Check if node's val is btw Min and Max, exclusive
            if Min < root.val < Max:
                res = canStillSearch(root.left, Min, root.val)
                if res:
                    return res and canStillSearch(root.right, root.val, Max)
                else:
                    return False
            else:
                return False
        
        return canStillSearch(root, -2**31-1, 2**31)



0322. Coin Change

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        '''
        Find the min number of coins to make amount. If impossible, return -1    
            
            -types:  coins (List[int])
                    amount (int)
            -rtype: int
        '''
        # Create an array, dp, with length = amount, to record min number of coins
        # from coin to make dp[i] for i = 0, 1, 2, ..., amount
        dp = [0]*(amount+1)
        
        # Convert coins to a set, so that search can be efficient
        coins = set(coins)
        
        # Loop dp. If dp[i] in coins, then dp[i] = 1.
        # Else, given dp[i], loop dp[i]-coin for every coin in coins,
        # and set dp[i] as min of 1 + dp[i]-coin, or 0 if its impossible
        for i in range(1, amount+1):
            if i in coins:
                dp[i] = 1
            else:
                dp[i] = [dp[i-c] for c in coins if i - c > 0 and dp[i-c] != 0]
                dp[i] = min(dp[i]) if dp[i] else 0
                if dp[i]:
                    dp[i] += 1
        
        # Return the last ele in dp, if it is not 0. Else, -1
        return dp[-1] if dp[-1] or amount == 0 else -1




Day 225, 02/22/2021 Mon

Find the Celebrity

class Solution:
    def findCelebrity(self, n: int) -> int:
        '''
        Find the celebrity among the n people. If there is not celebrity, return -1
        
            -type : n (int)
            -rtype: int
        '''
        # Find possible celebrity
        possible_celebrity = [i for i in range(n) if i and knows(0, i)]
        
        # Check if 0 is the celebrity
        if not possible_celebrity:
            i = 1
            while i < n:
                if not knows(i, 0):
                    return -1
                i += 1
            return 0 
        
        # Else, check all possible celebrity
        for x in possible_celebrity:
            # Check if all people know x
            i = 1
            who_know_you = 1
            while i < n:
                if x == i:
                    who_know_you += 1
                elif knows(i, x):
                    who_know_you += 1
                else:
                    break
                i += 1
            
            # Check if x does not know any one
            if who_know_you == n:
                j = 0
                while j < n:
                    if x != j and knows(x, j):
                        break
                    j += 1
                
                if j == n:
                    return x

        return -1



Longest Word in Dictionary through Deleting

class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        '''
        Find the longest string in d that can be formed by deleting some characters of s
            
            -types: s (str)
                    d (List[str])
            -rtype: str
        '''
        
        # Define a function to check if a word can be formed by deleting some characters of s
        def isAPart(word: str, s: str) -> bool:
            '''
            Determine if word can be formed by deleting some characters of s
            
                -types: word (str)
                           s (str)
                -rtype: bool
            '''
            i = j = 0
            l_w, l_s = len(word), len(s)
            
            while i < l_w and j < l_s:
                if word[i] == s[j]:
                    curr_i = i
                    next_j = j + 1
                 
                    while i < l_w and j < l_s:
                        if  word[i] == s[j]:
                            i += 1
                            j += 1
                        else:
                            j += 1
                    if i == l_w:
                        return True
                 
                    i, j = curr_i, next_j
                else:
                    j += 1
                
            return i == l_w
        
        
        max_l = 0
        res = ''
        for x in d:
            l = len(x)*isAPart(x, s)
            
            if max_l < l:
                max_l = l
                res = x
            elif max_l == l:
                res = min(res, x)
        
        return res        



0417. Pacific Atlantic Water Flow
          


Day 226, 02/23/2021 Tue

0074. Search a 2D Matrix

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        '''
        Determine if target is in matrix
        
            -types: matrix (List[List[int]])
                    target (int)
            -rtype: bool
        '''
        # Find height (h) and width (w) of matrix
        h, w = len(matrix), len(matrix[0])
        
        # Loop matrix from first row.
        # If target is btw first ele and last ele of this row, then search this row.
        # Start with the one of first ele and last ele, which is closer to target.
        # If not in this row, then search next row.
        # If teh first ele in a row is > target, then stop and return False
        for i in range(h):
            if matrix[i][0] <= target <= matrix[i][-1]:
                if target - matrix[i][0] <= matrix[i][-1] - target:
                    j = 0
                    while j < w and matrix[i][j] <= target:
                        j += 1
                    if matrix[i][j-1] == target:
                        return True
                else:
                    j = w-1
                    while j > -1 and matrix[i][j] >= target:
                        j -= 1
                    if matrix[i][j+1] == target:
                        return True   
            elif matrix[i][0] > target:
                return False
        return False       



Search a 2D Matrix II

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        '''
        Determine if target is in matrix
        
            -types: matrix (List[List[int]])
                    target (int)
            -rtype: bool
        '''
        # Find height (h) and width (w) of matrix
        h, w = len(matrix), len(matrix[0])
        
        # Loop matrix from first row.
        # If target is btw first ele and last ele of this row, then search this row.
        # Start with the one of first ele and last ele, which is closer to target.
        # If not in this row, then search next row.
        # If teh first ele in a row is > target, then stop and return False
        for i in range(h):
            if matrix[i][0] <= target <= matrix[i][-1]:
                if target - matrix[i][0] <= matrix[i][-1] - target:
                    j = 0
                    while j < w and matrix[i][j] <= target:
                        j += 1
                    if matrix[i][j-1] == target:
                        return True
                else:
                    j = w-1
                    while j > -1 and matrix[i][j] >= target:
                        j -= 1
                    if matrix[i][j+1] == target:
                        return True            
        return False



Day 227, 02/24/2021 Wed

Score of Parentheses

class Solution:
    def scoreOfParentheses(self, S: str) -> int:
        '''
        Find the score of S based on the balance rule 
        
            -type : S (str)
            -rtype: int
        '''
        i = len(S)-1
        stack = []
        
        # Loop S from the very last element
        while i > -1:
            # If current element is a ), then append it to stack
            if S[i] == ')':
                stack.append(S[i])
                i -= 1
            
            # If current element is a (
            else:
                # Check if stack is not empty. If no, just return 0.
                if stack == []:
                    return 0
                # If the last element of stack is a number, pop stack as header.
                # Multiply header by 2, pop the next (, and put header back to stack
                elif stack and stack[-1] not in ['(',')']:
                    header = 2*stack.pop()
                    if stack:
                        stack.pop()
                    
                    if stack and stack[-1] not in ['(',')']:
                        stack[-1] += header
                    else:
                        stack.append(header)
                    i -= 1

                # If the last element of stack is a ), set header = -1
                # Pop stack until stack is empty or stack[-1] is not a )
                # Increment header every pop, and 2^header is the number
                # need to put back to stack.
                # Before putting  2^header to stack, check if stack is not empty
                # and its last element is a number. If yes, then add 2 ** header to
                # its last element. Otherwise, append 2 ** header to stack.
                elif stack and stack[-1] == ')':
                    header = -1
                    while stack and stack[-1] == ')' and i >-1 and S[i] == '(':
                        stack.pop()
                        header += 1
                        i -= 1
                    if stack and stack[-1] != ')':
                        stack[-1] += 2 ** header
                    else:
                        stack.append(2 ** header)
            print(i, stack)
        return sum(stack)



Day 228, 02/25/2021 Thu

Shortest Unsorted Continuous Subarray

class Solution:
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        '''
        Find the length of a continuous subarray such sorting it will make the entire array sorted
        
            -type : nums (List[int]) 
            -rtyep: int
        '''
        # Find length of nums
        l = len(nums)
        
        # Initiate two pointers from both ends
        i, j = 0, l-1
        
        # Special case when nums[i] > nums[j]
        if nums[i] > nums[j]:
            return l
        
        # Loop nums from both ends, to find max possible i and min possible j
        # such that all eles before i/after j are sorted
        while i < j and nums[i] <= nums[i+1]:
            i += 1
        while i < j and nums[j-1] <= nums[j]:
            j -= 1    
        
        # Case when array sorted
        if i == j:
            return 0
        
        # Decreasing i/ increasing j to make nums[i] <= nums[j]
        while nums[i] > nums[j]:
            if (i > 0 and nums[i-1] < nums[j]) or (j == l-1 and i > 0):
                i -= 1
            elif (j < l-1 and nums[i] < nums[j+1]) or (i == 0 and j < l-1):
                j += 1
            else:
                i -= 1
                j += 1        
 
        # Find min and max btw nums[i] and nums[j]
        Min, Max = min(nums[i+1:j]), max(nums[i+1:j])
        
        # Decrease i until nums[i] <= min of nums[i+1:j],
        # and meanwhile update max of nums[i+1:j]
        while i >= 0 and nums[i] > Min:
            Max = max(Max, nums[i])
            i -= 1
            
        # Increase j until nums[j] >= max of nums[i+1:j]
        while j < l and nums[j] < Max:
            j += 1
        
        return j - i - 1



0723. Candy Crush

class Solution:
    def candyCrush(self, board: List[List[int]]) -> List[List[int]]:
        '''
        Perform a basic elimination algorithm for Candy Crush untik the board is stable
        
            -type : board (List[List[int]])
            -rtype: List[List[int]]
        '''
        # Find height and width of board
        h, w = len(board), len(board[0])
        
        # Create a referece board, visited, to record what cells have been
        # visited at current step
        self.visited = [[0 for _ in range(w)] for _ in range(h)]
        
        # Create a variable, num_of_visited, to record how many cells have been visited
        # And another variable, self.last_num_of_visited, to record its value in last update 
        self.num_of_visited = 0
        self.last_num_of_visited = -1
        
        # Define a function, cellsToEliminate, to find cells need to eliminate
        # Cells in self.visited_cells can indicate what cells will be eliminated
        def findCandiesToEliminate(board: List[List[int]], h: int, w: int) ->None:
            '''
            Find cells need to eliminate
            
                -types: board (List[List[int]])
                            h (int)
                            w (int)
                -rtype: None 
            '''
            # Loop every cell and find if 3 or more candies of the same type are 
            # adjacent vertically or horizontally, and mark self.visited
            for i in range(h):
                for j in range(w):
                    if not self.visited[i][j]:
                        x, y = i, j
                        
                        # Check if 3 or more candies of the same type are adjacent vertically
                        while x + 2 < h and board[x][y] == board[x+1][y] == board[x+2][y]:
                            self.num_of_visited += self.visited[x][y] != 1
                            self.num_of_visited += self.visited[x+1][y] != 1
                            self.num_of_visited += self.visited[x+2][y] != 1
                            self.visited[x][y] = 1
                            self.visited[x+1][y] = 1
                            self.visited[x+2][y] = 1
                            x += 1 
                        x = i
                        
                        while x + 1 < h and x - 1 >= 0 and board[x-1][y] == board[x][y] == board[x+1][y]:
                            self.num_of_visited += self.visited[x-1][y] != 1
                            self.num_of_visited += self.visited[x][y] != 1
                            self.num_of_visited += self.visited[x+1][y] != 1
                            self.visited[x-1][y] = 1
                            self.visited[x][y] = 1
                            self.visited[x+1][y] = 1
                            x += 1 
                        x = i
                        
                        while x - 2 >= 0 and x < h and board[x-2][y] == board[x-1][y] == board[x][y]:
                            self.num_of_visited += self.visited[x-2][y] != 1
                            self.num_of_visited += self.visited[x-1][y] != 1
                            self.num_of_visited += self.visited[x][y] != 1
                            self.visited[x-2][y] = 1
                            self.visited[x-1][y] = 1
                            self.visited[x][y] = 1
                            x += 1 
                        x = i
                        
                        # Check if 3 or more candies of the same type are adjacent horizontally
                        while y + 2 < w and board[x][y+1] == board[x][y] == board[x][y+2]:
                            self.num_of_visited += self.visited[x][y] != 1
                            self.num_of_visited += self.visited[x][y+1] != 1
                            self.num_of_visited += self.visited[x][y+2] != 1
                            self.visited[x][y] = 1
                            self.visited[x][y+1] = 1
                            self.visited[x][y+2] = 1
                            y += 1 
                        y = j
                        
                        while y + 1 < w and y - 1 >= 0 and board[x][y-1] == board[x][y] == board[x][y+1]:
                            self.num_of_visited += self.visited[x][y-1] != 1
                            self.num_of_visited += self.visited[x][y] != 1
                            self.num_of_visited += self.visited[x][y+1] != 1
                            self.visited[x][y-1] = 1
                            self.visited[x][y] = 1
                            self.visited[x][y+1] = 1
                            y += 1 
                        y = j
                        
                        while y - 2 >= 0 and y < w and board[x][y-2] == board[x][y-1] == board[x][y]:
                            self.num_of_visited += self.visited[x][y-2] != 1
                            self.num_of_visited += self.visited[x][y-1] != 1
                            self.num_of_visited += self.visited[x][y] != 1
                            self.visited[x][y-2] = 1
                            self.visited[x][y-1] = 1
                            self.visited[x][y] = 1
                            y += 1 
                        y = j
                        
        
        # Define a fucntion updateBoard, to update board based on visited candies
        def updateBoard(board: List[List[int]], h: int, w: int) -> List[List[int]]:
            '''
            Update board based on visited candies
                 -types: board (List[List[int]])
                            h (int)
                            w (int)
                -rtype: None           
            '''
            # For each column, update candy positions after elimination
            for j in range(w):
                cells_go_down = 0
                i = h-1
                while i > -1:
                    if cells_go_down and not self.visited[i][j]:
                        board[i+cells_go_down][j] = board[i][j]
                    cells_go_down += self.visited[i][j]
                    i -= 1
                
                # Fill all candies above eliminated cells as 0
                cells_go_down -= 1
                while cells_go_down > -1:
                    board[cells_go_down][j] = 0
                    cells_go_down -= 1
                    
            return board
        
        # Update board until board is stable
        while self.num_of_visited != self.last_num_of_visited:
            self.last_num_of_visited = self.num_of_visited
            self.num_of_visited = 0
            findCandiesToEliminate(board, h, w)
            board = updateBoard(board, h, w)
            self.visited = [[0 for _ in range(w)] for _ in range(h)]
        
        return board
            


0542. 01 Matrix



Day 229, 02/26/2021 Fri

Validate Stack Sequences

0909. Snakes and Ladders



Day 230, 02/27/2021 Sat

Divide Two Integers

class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        '''
        Divide dividend by divisor without using multiplication, division, and mod operator
        
            -types: dividend (int)
                     divisor (int)
            -rtype: int 
        '''
        # If dividend is 0, just return 0
        if dividend == 0:
            return 0
            
        # Determine sign of final result
        if dividend > 0 and divisor > 0 or dividend < 0 and divisor < 0:
            sign = 1
        else:
            sign = -1

        # Since divisor != 0, convert both divisor and dividend to
        # abs(divisor) from abs(dividend). Use math functions to find
        # the quote (res)
        dividend, divisor = abs(dividend), abs(divisor)
        import math
        res = int(2 ** (math.log2(dividend) - math.log2(divisor)))
        
        if res < -2**31 or res > 2**31-1:
            return 2**31-1
        return sign*res
        
        # Avoid overflow
        if quote < -2**31 or quote > 2**31-1:
            return 2**31-1
        
        # Return the quote, with multiplying original sign
        return sign*quote



Day 231, 02/28/2021 Sun


Day 232, 03/01/2021 Mon

Single-Row Keyboard

class Solution:
    def calculateTime(self, keyboard: str, word: str) -> int:
        '''
        Calculate how much time it takes to type word with one finger in keyboard
        
            -type: keyboard (str)
                       word (str)
            -rtype: int
        '''
        # Use a dictionary, d, to indicate position of each char in keyboard
        d = {k:v for k, v in zip(keyboard, range(26))}
        
        # Find cumulative distance of char in word based on d
        res = [abs(d[word[i]]-d[word[i-1]]) for i in range(1, len(word))]
        return d[word[0]] + sum(res)



Distribute Candies

class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        '''
        Find the maximum number of different types of candies she can eat if she only eats n / 2 of them
        
            -type : candyType (List[int])
            -rtype: int
        '''
        # Find number of different types of candies
        n_diff = len(set(candyType))
        
        # 
        return min(len(candyType)//2, n_diff)
        
        

0822. Card Flipping Game

class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        '''
        Find the smallest number that is good.  If no number is good, output 0.
        
            -types: fronts (List[int])
                     backs (List[int])
            -rtype: int
        '''
        # Loop front and back at the same time.
        # Find cards that has same value on front and back, and put its 
        # value in a set, impossible
        impossible = set()
        for i in range(len(fronts)):
            if fronts[i] == backs[i]:
                impossible.add(fronts[i])
        
        # Loop front and back at the same time and find the good card
        good_card = 2001
        for i in range(len(fronts)):
            if fronts[i] not in impossible and backs[i] not in impossible:
                good_card = min(fronts[i], backs[i], good_card)
            elif fronts[i] not in impossible and backs[i] in impossible:
                good_card = min(fronts[i], good_card)
            elif backs[i] not in impossible and fronts[i] in impossible:    
                good_card = min(backs[i], good_card)
            
        return good_card if good_card <= 2000 else 0



Day 233, 03/02/2021 Tue
Day 234, 03/03/2021 Wed
Day 235, 03/04/2021 Thu
Day 236, 03/05/2021 Fri
Day 237, 03/06/2021 Sat
Day 238, 03/07/2021 Sun
Day 239, 03/08/2021 Mon
Day 240, 03/09/2021 Tue
Day 241, 03/10/2021 Wed
Day 242, 03/11/2021 Thu

Day 243, 03/12/2021 Fri

Strobogrammatic Number

class Solution:
    def isStrobogrammatic(self, num: str) -> bool:
        '''
        Determine if num is a strobogrammatic number
        
            - type: str
            -rtype: bool
        '''
        # Create a dictionary, d, to map a didgit and its strobogrammatic number
        d = {'6': '9', '9': '6', '0': '0', '8': '8', '1':'1'}
        
        # Create another num, n.
        # Reverse n and map all its chars to their corresponding strobogrammatic numbers
        n = list(reversed(num))

        for i in range(len(n)):
            if n[i] not in d:
                return False
            n[i] = d[n[i]]
        
        # Find if n is exactly num

        return num == ''.join(n)



Check If a String Contains All Binary Codes of Size K

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        '''
        Determine if every binary code of length k is a substring of s
        
            -types: s (str)
                    k (int)
            -rtype: bool
        '''
        # Loop s and find all its unique substrings with length = k,
        # and put them in a set, substrings
        substrings = set()
        for i in range(len(s)-k+1):
            substrings.add(s[i:i+k])
        
        # Check if length of substrings == 2 ** k.
        return len(substrings) == 2 ** k



Day 244, 03/13/2021 Sat

Binary Trees With Factors

class Solution:
    def numFactoredBinaryTrees(self, arr: List[int]) -> int:
        '''
        Find the number of binary tress where each non-leaf node's value
        should be equal to the product of the values of its children.
        
            -type : arr (List[int])
            -rtype: int
        '''
        # Create a dictionary, nodes, with key = val for arr and value = 
        # a list of lists representing possible children
        nodes = {k:v for k, v in zip(arr, [[] for _ in range(len(arr))])}
        
        # Sort arr and Loop arr to find all possibel product of any two
        # elements and the product is also in arr/nodes
        arr.sort()
        for i in range(len(arr)):
            for j in range(i, len(arr)):
                if arr[i]*arr[j] in nodes:
                    if arr[i] == arr[j]:
                        nodes[arr[i]*arr[j]].append([arr[i], arr[j]])
                    else:
                        nodes[arr[i]*arr[j]].append([arr[i], arr[j]])
                        nodes[arr[i]*arr[j]].append([arr[j], arr[i]])
        
        
        # Remove keys in nodes where their value = []
        nodes = {k: v for k, v in nodes.items() if v}
        
        from functools import reduce
        curr_nodes = reduce(lambda x, y: x + y, nodes[max(nodes)])
        res += len(nodes[max(nodes)]) + 1
        while curr_node:     



Day 245, 03/14/2021 Sun
Day 239, 03/08/2021 Mon
Day 240, 03/09/2021 Tue
Day 241, 03/10/2021 Wed
Day 242, 03/11/2021 Thu
Day 243, 03/12/2021 Fri
Day 244, 03/13/2021 Sat
Day 245, 03/14/2021 Sun
Day 246, 03/15/2021 Mon
Day 247, 03/16/2021 Tue
Day 248, 03/17/2021 Wed
Day 249, 03/18/2021 Thu
Day 250, 03/19/2021 Fri
Day 251, 03/20/2021 Sat
Day 252, 03/21/2021 Sun
Day 253, 03/22/2021 Mon
Day 254, 03/23/2021 Tue
Day 255, 03/24/2021 Wed
Day 256, 03/25/2021 Thu
Day 257, 03/26/2021 Fri
Day 258, 03/27/2021 Sat
Day 259, 03/28/2021 Sun
Day 260, 03/29/2021 Mon
Day 261, 03/30/2021 Tue
Day 262, 03/31/2021 Wed

Day 263, 04/01/2021 Thu

Largest Unique Number

class Solution:
    def largestUniqueNumber(self, A: List[int]) -> int:
        '''
        Find the largest integer that only occurs once. Otherwise, return -1.
        
            -type : A (List[int])
            -rtype: int
        '''
        # Use a counter to filter out intgers only occur once, and find the largest one.
        # If the counter is empty, then return -1
        from collections import Counter
        res = [k for k in Counter(A) if Counter(A)[k] == 1]
        
        return max(res) if res else -1



Palindrome Linked List

class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        '''
        Determine if head is a palindrome.
        
            -type : head (ListNode)
            -rtype: bool
        '''
        # Find length of this list
        head_l = head
        l = 0
        while head_l:
            l += 1
            head_l = head_l.next
        
        # Find the second half of the list
        l = (l+1)//2 if l%2 else l//2
        second_half = head
        while l:
            second_half = second_half.next
            l -= 1
        
        # Reverse the second half
        new_head = None
        while second_half:
            temp = second_half
            second_half = second_half.next
            temp.next = new_head
            new_head = temp

        # Compare head and new_head
        while new_head:
            if new_head.val != head.val:
                return False
            new_head = new_head.next
            head = head.next
        
        return True



1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts

class Solution:
    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:
        '''
        Find the maximum area of a piece of cake after cut at all horizontal and vertical positions
        
            -types:              h (int)
                                 w (int)
                    horizontalCuts (List[int])
                      verticalCuts (List[int])
            -rtype: int
        '''
        # Sort and find distance between each cut
        horizontalCuts.sort()
        verticalCuts.sort()
        horizontalCuts = [0] + horizontalCuts + [h]
        verticalCuts = [0] + verticalCuts + [w]
        horizontalCuts = [horizontalCuts[i]-horizontalCuts[i-1] for i in range(1, len(horizontalCuts))]
        verticalCuts = [verticalCuts[i]-verticalCuts[i-1] for i in range(1, len(verticalCuts))]
        
        # Return the max product
        return max(horizontalCuts)*max(verticalCuts) % (10**9+7)


Day 264, 04/02/2021 Fri

0039. Combination Sum

class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        '''
        '''
0739. Daily Temperatures

class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        

        
Day 265, 04/03/2021 Sat
Day 266, 04/04/2021 Sun

Day 267, 04/05/2021 Mon

Global and Local Inversions

class Solution:
    def isIdealPermutation(self, A: List[int]) -> bool:
        '''
        Determine iff the number of global inversions is equal to the number of local inversions.
            
            -type : A (List[int])
            -rtype: bool
        '''
        # Check if every number changed its position at most 1.
        return max([abs(j-i) for i, j in enumerate(A)]) <= 1



Day 268, 04/06/2021 Tue
Day 269, 04/07/2021 Wed
Day 270, 04/08/2021 Thu
Day 271, 04/09/2021 Fri
Day 272, 04/10/2021 Sat
Day 273, 04/11/2021 Sun
Day 274, 04/12/2021 Mon
Day 275, 04/13/2021 Tue
Day 276, 04/14/2021 Wed
Day 277, 04/15/2021 Thu
Day 278, 04/16/2021 Fri
Day 279, 04/17/2021 Sat
Day 280, 04/18/2021 Sun

Day 281, 04/19/2021 Mon

Minimum Swaps to Group All 1's Together

class Solution:
    def minSwaps(self, data: List[int]) -> int:
        """
        Find the minimum number of swaps required to group all 1’s together
        
            -type : data (List[int])
            -rtype: int
        """
        # Find sum of data
        s = sum(data)
        
        # Case when no 1, or just one 1
        if s in [0, 1]: return 0
        
        # Find the max number of ones in data[i:i+s], where
        # i = 0, 1,..., len(data)-s, and subtract it from s
        Sum = currSum = sum(data[:s])
        for i in range(1, len(data)-s+1):
            currSum += data[s+i-1] - data[i-1]
            Sum = max(Sum, currSum)
        return s - Sum



Day 282, 04/20/2021 Tue

Day 283, 04/21/2021 Wed

Triangle



Day 284, 04/22/2021 Thu

Brick Wall

class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        '''
        Find out a line to cross the least bricks and return the number of crossed bricks.
        
            -type : wall (List[List[int]])
            -rtype: int
        '''
        # Find out height of the wall, and total width of wach row
        h, w = len(wall), sum(wall[0])
        
        
        # Find cumulative sum at each position on each row
        for i in range(h):
            for j in range(1, len(wall[i])):
                wall[i][j] += wall[i][j-1]
        
        # Convert wall to a 1-d array
        from functools import reduce
        wall = reduce(lambda x, y : x + y, wall)
        
        # Remove the very end edge in each row
        wall = [x for x in wall if x != w]
        
        # Find the most common edges, and subtract it from h if wall is not empty
        # Otherwise, just return h
        from collections import Counter
        return h - Counter(wall).most_common(1)[0][1] if wall else h
    



Day 285, 04/23/2021 Fri

1328. Break a Palindrome

class Solution:
    def breakPalindrome(self, palindrome: str) -> str:
        '''
        Replace exactly one character to break palindrome and that it is the lexicographically smallest one possible
        
            -type : palindrome (str)
            -rtype: str
        '''
        # Find length of palindrome
        l = len(palindrome)
        
        # If its length is 1, then there is no way to break palindrome
        if l == 1: return ''
                
        # Convert palindrome to a list
        palindrome = list(palindrome)
            
        # Loop the first half, and replace the first char that is not 'a'
        i = 0
        while i < l//2 and palindrome[i] == 'a':
            i += 1
        
        # Check if i is in the middle of the string
        if i == l//2:
            # Case when length of l is even
            if l%2 == 0:
                palindrome[l-i] = 'b'
            # Case when length of l is odd
            else:
                if palindrome[i] == 'a':
                    palindrome[-1] = 'b'
                else:
                    palindrome[-1] = 'b'

            # Else, replace char at i with 'a' and return palindrome as a str

        # If no, replace ith char to 'a' and return palindrome as a str
        else:
            palindrome[i] = 'a'
            
        return ''.join(palindrome) 
        
        
        

Day 286, 04/24/2021 Sat

Day 287, 04/25/2021 Sun

1152. Analyze User Website Visit Pattern

class Solution:
    def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -> List[str]:
        '''
        Find the 3-sequence visited by the largest number of users.
        
            -types:  username (List[str]) 
                    timestamp (List[int]) 
                      website (List[str])
            -rtype: List[str]
        '''
        # Create a dictionary, d, with key = timestamp and value = [username, website] 
        d = {y:[x, z] for x, y, z in zip(username, timestamp, website)}
        
        # Create another dictionary, d1, with key = username, and value = a list of
        # webistes visited by timestamp in an ascending order. Always keey length of
        # value <= 3
        d0 = {}
        
        # Create a counter, to count frequency of each 3-sequence
        from collections import Counter
        cnt = Counter()
        
        # Meanwhile, loop d from 0 to max of timestamp
        # Once see a user, append website at this timestamp to its value
        for t in sorted(timestamp):
            if t in d:
                if d[t][0] in d0:
                    d0[d[t][0]].append(d[t][1])
                else:
                    d0[d[t][0]] = [d[t][1]]
        
        # For each user, find all possible combo of 3
        from itertools import combinations
        d0 = {k: list(combinations(d0[k], 3)) for k in d0}
        d0 = {k: list(set([','.join(x) for x in d0[k]])) for k in d0}
        
        # Combine all values in do to a list, and convert all values in format
        # as a string of original values seperated by comma
        from functools import reduce
        d0 = reduce(lambda x, y : x + y, d0.values())
        
        # Find the smallest most frequent ele in cnt, and seperate it to a list
        from collections import Counter
        cnt = Counter(d0)
        return min([k for k in cnt if cnt[k] == cnt.most_common(1)[0][1]]).split(',')
        


Day 288, 04/26/2021 Mon

Furthest Building You Can Reach



Day 289, 04/27/2021 Tue

0934. Shortest Bridge



Day 290, 04/28/2021 Wed

0062. Unique Paths

class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        '''
        Find how many possible ways with moving either down or right
        from the top-left corner to the the bottom-right corner.
        
            -types: m (int)
                    n (int)
            -rtype: int
        '''
        # Initiate the grids, and assign the start grid as 1
        # Assign the two grids next to the top-left corner to 1
        res = [[0 for _ in range(n)] for _ in range(m)]
        res[0][0] = 1
        if n > 1: res[0][1] = 1
        if m > 1: res[1][0] = 1
        
        # Loop the grid, and its value = sum of cell value from
        # left and up
        for i in range(m):
            for j in range(n):
                if res[i][j] == 0:
                    res[i][j] += res[i][j-1] if j-1 > -1 else 0
                    res[i][j] += res[i-1][j] if i-1 > -1 else 0
        return res[-1][-1]
            



Unique Paths II

class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        '''
        Find how many unique paths would there be that the robot can move from the
        left-top to the right-bottom corner, with only moving down or right.
        
            -type : obstacleGrid (List[List[int]])
            -rtype: int
        '''
        # Find height and width of obstacleGrid
        h, w = len(obstacleGrid), len(obstacleGrid[0])
        
        # Loop obstacleGrid from left-top to right-bottom
        # If the grid is originally 1, then set it to 0
        # Else, assign it to the sum of values from left
        # and top cells.
        obstacleGrid[0][0] = 1
        for i in range(h):
            for j in range(w):
                if obstacleGrid[i][j] == 0:
                    obstacleGrid[i][j] += obstacleGrid[i][j-1] if j-1 >= 0 else 0
                    obstacleGrid[i][j] += obstacleGrid[i-1][j] if i-1 >= 0 else 0
                elif i + j > 0:
                    obstacleGrid[i][j] = 0
 
        return obstacleGrid[-1][-1]
        
        


Day 291, 04/29/2021 Thu

Find First and Last Position of Element in Sorted Array

class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        '''
        Find the starting and ending position of target.
        
           -types:   nums (List[int]) 
                   target (int)
           -rtype: List[int]
        '''
        # Use bisect to find first and last position
        import bisect
        start, end = bisect.bisect_left(nums, target), bisect.bisect_right(nums, target)
        
        return [-1, -1] if start == end else [start, end-1]
        


Meeting Scheduler


Day 292, 04/30/2021 Fri

Day 293, 05/01/2021 Sat

Number of Connected Components in an Undirected Graph

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        '''
        Find the number of connected components in the graph.
        
            -types:     n (int)
                    edges (List[List[int]])
            -rtype: int
        '''
        # Create a dictionary, connections, with looping edges to find
        # connections between nodes
        connections = {}
        for [n1, n2] in edges:
            if n1 in connections:
                connections[n1].append(n2)
            else:
                connections[n1] = [n2]
            
            if n2 in connections:
                connections[n2].append(n1)
            else:
                connections[n2] = [n1]
        
        # Create another dictionary, group, with key = node ID and value = group ID
        # Initiate all group Id as None
        group = {k:v for k, v in zip(range(n), [None]*n)}
        
        # Initiate an new variable, group_num = 0.
        group_num = 0
        
        # Create a function to assign all connected nodes to the same group
        def assignGroup(curr_node: int, connections: dict, group: dict, group_num: int) -> None:
            '''
            Assign all connected nodes to the same group.
            
                -types:   curr_node (int)
                        connections (dict)
                              group (dict)
                          group_num (int) 
                -rtype: None
            '''
            group[curr_node] = group_num
            if curr_node in connections:
                for node in connections[curr_node]:
                    if group[node] == None:
                        assignGroup(node, connections, group, group_num)

        # Loop all nodes. 
        # If current node has group = None, then loop all its connected nodes in connections, 
        # and assign all its connect nodes to group_num.
        # After completing looping, increment group_num.
        
        for i in range(n):
            if group[i] == None:
                assignGroup(i, connections, group, group_num)
                group_num += 1
                    
        return group_num
        
        

Day 294, 05/02/2021 Sun
Day 295, 05/03/2021 Mon
Day 296, 05/04/2021 Tue
Day 297, 05/05/2021 Wed
Day 298, 05/06/2021 Thu
Day 299, 05/07/2021 Fri
Day 300, 05/08/2021 Sat
Day 301, 05/09/2021 Sun
