Day 001, 07/13/2020 Mon
Day 002, 07/14/2020 Tue
Day 003, 07/15/2020 Wed
Day 004, 07/16/2020 Thu
Day 005, 07/17/2020 Fri
Day 006, 07/18/2020 Sat
Day 007, 07/19/2020 Sun
Day 008, 07/20/2020 Mon
Day 009, 07/21/2020 Tue
Day 010, 07/22/2020 Wed
Day 011, 07/23/2020 Thu
Day 012, 07/24/2020 Fri
Day 013, 07/25/2020 Sat
Day 014, 07/26/2020 Sun
Day 015, 07/27/2020 Mon
Day 016, 07/28/2020 Tue
Day 017, 07/29/2020 Wed
Day 018, 07/30/2020 Thu
Day 019, 07/31/2020 Fri
Day 020, 08/01/2020 Sat
Day 021, 08/02/2020 Sun
Day 022, 08/03/2020 Mon
Day 023, 08/04/2020 Tue
Day 024, 08/05/2020 Wed
Day 025, 08/06/2020 Thu
Day 026, 08/07/2020 Fri
Day 027, 08/08/2020 Sat
Day 028, 08/09/2020 Sun
Day 029, 08/10/2020 Mon
Day 030, 08/11/2020 Tue
Day 031, 08/12/2020 Wed
Day 032, 08/13/2020 Thu
Day 033, 08/14/2020 Fri
Day 034, 08/15/2020 Sat
Day 035, 08/16/2020 Sun

Day 036, 08/17/2020 Mon

1385. Find the Distance Value Between Two Arrays

class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        '''
        Find the distance between arr1 and arr2.
        
            types: arr1 (List[int])
                   arr2 (List[int])   
                      d (int)
            rtype: int
        '''
        return sum([not any([abs(x - y) <= d for y in arr2]) for x in arr1])



0748. Shortest Completing Word

class Solution:
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        '''
        Find the minimum length word from a given dictionary words, 
        which has all the letters from the string licensePlate.
        
            types: licensePlate (str) 
                          words (List[str])
            rtype: str
        '''
        # Filter out non-alphabetics chars in licensePlate,
        # and convert all chars to lower case.
        licensePlate = list(licensePlate)
        licensePlate = [x.lower() for x in licensePlate if x.isalpha()]
        licensePlate = ''.join(licensePlate)
        
        # Convert all letters in words to lower case
        words = [x.lower() for x in words]
        
        # Use counter to find the first word such that licensePlate is a subset of it.
        # If it is, then check if current word has smaller length and res. If yes, then 
        # assign this word to res. Otherwise, continue.
        res = 'a'*1000
        from collections import Counter
        plate_cnt = Counter(licensePlate)
        for word in words:
            cnt = Counter(word)
            if len(cnt - plate_cnt) >= 0 and len(plate_cnt - cnt) == 0:
                if len(word) < len(res):
                    res = word
        return res



0949. Largest Time for Given Digits

class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        '''
        Find the largest 24 hour time that can be made. 
        If no valid time can be made, return an empty string.
        
            type : A (List[int])
            rtype: str
        '''
        # Initiate result, res
        res = ''
        
        # Loop A. For each loop, find the largest legal hour, and 
        # check if min will also will be legal.
        current_h = current_m = -1
        for i in range(4):
            for j in range(4):
                # Create largest legal hour using two different ele
                if i != j and current_h <= 10*A[i] + A[j] < 24:
                    # Check if the other two eles and create legal min.
                    # If yes, find the largest one.
                    minute = [A[x] for x in range(4) if x not in [i, j]]
                    minute = [10 * minute[0] + minute[1], 10 * minute[1] + minute[0]]
                    minute = [x for x in minute if x < 60]
                    
                    if minute:
                        if 10*A[i] + A[j] == current_h and current_m < max(minute):
                                current_m = max(minute)
                        elif 10*A[i] + A[j] > current_h:
                                current_h = 10*A[i] + A[j]
                                current_m = max(minute)
                            
        if current_h == -1 and current_m == -1:
            return ''
        # Add leading zero if either of current_h or current_m is < 10
        current_h = '0' + str(current_h) if current_h < 10 else str(current_h)
        current_m = '0' + str(current_m) if current_m < 10 else str(current_m)
        
        return current_h  + ":" + current_m


Day 037, 08/18/2020 Tue



Day 038, 08/19/2020 Wed

1317. Convert Integer to the Sum of Two No-Zero Integers

class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        '''
        Convert n to the sum of two integers without 0
        
            -type : n (int)
            -rtype: List[int]
        '''
        # Loop n from 1 to n//2.
        # If neither of x or n-x contains 0, then return [x, n-x] 
        for x in range(1, n//2+1):
            if '0' not in str(x) and '0' not in str(n-x):
                return [x, n-x]



0257. Binary Tree Paths

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:



1078. Occurrences After Bigram

class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        '''
        Find all words after occurences of first and second word
        
            -type : text (str)
            -type : first (str)
            -type : second (str)
            -rtype: List[str]
        '''
        # Spilt text to a list
        text = text.split(' ')
        
        # Loop text and find such a pattern
        i = 0
        l = len(text) - 2
        res = []
        while i < l:
            if text[i] == first and text[i+1] == second:
                res.append(text[i+2])
            i += 1
        
        return res



Day 039, 08/20/2020 Thu

1507. Reformat Date

cclass Solution:
    def reformatDate(self, date: str) -> str:
        '''
        Refromat date to format YYYY-MM-DD
        
            -type : date (str)
            -rtype: str
        '''
        
        # Splite date by spaces
        date = date.split(' ')
        
        # Remove chars in day
        date[0] = [x for x in date[0] if x.isnumeric()]
        date[0] = ''.join(date[0]) if len(date[0]) == 2 else '0'+date[0][0]
        
        import calendar
        date[1] = str(list(calendar.month_abbr).index(date[1]))
        date[1] = '0'+date[1] if len(date[1]) == 1 else date[1]
        
        return date[2] + '-' + date[1] + '-' + date[0]



1486. XOR Operation in an Array

class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        '''
        Create and find XOR of all elements of nums
            
            -type :     n (int)
                    start (int)
            -rtype: int
        '''
        # Create nums
        nums = [start + 2*i for i in range(n)] 
        
        # Return the bitwise XOR
        from functools import reduce
        return reduce(lambda x, y: x^y, nums)



0669. Trim a Binary Search Tree

class Solution:
    def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:
        


Day 040, 08/21/2020 Fri
Day 041, 08/22/2020 Sat
Day 042, 08/23/2020 Sun

Day 043, 08/24/2020 Mon

0160. Intersection of Two Linked Lists

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:



0763. Partition Labels

class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        '''
        Find size of each partiton part of S, where each letter appears in at most one part
        
            -type : S (str)
            -rtype: List[int]
        '''
        # Counter frequency of each letter
        from collections import Counter
        freq = Counter(S)
        
        # Convert S to list of chars
        S = list(S)
        
        # Initiate result as res
        res = []
        
        # Loop S (reversely).
        # Find partion points and record length of each partition.
        # Use a set to record all chars seen. If freq of this char is 0,
        # check if all othe chars in the set are also 0. 
        # If yes, partition poin found; else, continue.
        holder = set([])  # Remember uniqe chars from S
        cnt = 0           # Record length of current partition 
        while S:
            temp = S.pop() # Pop and record last char in S 
            freq[temp] -= 1
            holder.add(temp)
            cnt += 1
            if freq[temp] == 0:
                if sum([freq[x] for x in holder]) == 0: # Partiton point found
                    res.append(cnt)
                    # Reset holder and cnt #
                    holder = set([])
                    cnt = 0
        
        # Reverse res (since S is popped reversely)
        res.reverse()
        
        return res



Day 044, 08/25/2020 Tue



Day 045, 08/26/2020 Wed

0944. Delete Columns to Make Sorted

class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        '''
        Find the minimum possible length of D (delection set) s.t. 
        each remaining column in A is in non-decreasing sorted order
        
            -type : A (List[str])
            -rtype: int
        '''
        res = 0    # Initiate result, length of deletion set
        
        # Special case
        if len(A) == 1:
            return 0
            
        # Loop index i of each word in A.
        # If, for an index i, A[x-1][i] > A[x][i], incremnent res and start next index
        for i in range(len(A[0])):
            for x in range(1, len(A)):
                if A[x-1][i] > A[x][i]:
                    res += 1
                    break
        return res



1431. Kids With the Greatest Number of Candies

class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        '''
        Find if every kid in candies can have the greatest number of candies with extraCandies
        
            -type :      candies (List[int])
                    extraCandies (int)
            -rtype: List[bool]  
        '''
        # Find max of candies
        m = max(candies)
        
        # Loop candies.
        # Determine if ith candy + extraCandies >= m
        return [c+extraCandies >= m for c in candies]

        
        
0131. Palindrome Partitioning

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        '''
        Partition s such that every substring of the partition is a palindrome
        
            -type : s (str)
            -rtype: List[List[str]]
        '''
        if len(s) == 1:
            return [[s]]
        else:
            res = []
            i = 0
            while i < len(s)-1:
                if self.isPalindrome(s[:(i+1)]):
                    res.extend([[s[:(i+1)]] + x for x in self.partition(s[(i+1):])])
                i += 1
            if self.isPalindrome(s):
                res.append([s])
            return res

    def isPalindrome(self, s: str) -> bool:
        '''
        Determine if s is palindrome
        
            -type : s (str)
            -rtype: bool  
        '''
        # If empty, yes
        if not s:
            return False
        
        # Loop s from both ends and check
        i, j = 0, len(s) - 1
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True



Day 046, 08/27/2020 Thu
Day 047, 08/28/2020 Fri
Day 048, 08/29/2020 Sat
Day 049, 08/30/2020 Sun



Day 050, 08/31/2020 Mon

0938. Range Sum of BST

class Solution:
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
        '''
        Find the sum of node values between L and R, inclusive
            
            -type : root (TreeNode)
                       L (int)
                       R (int)
            -rtype: int
        '''
        # Check if root is NULL:
        if not root:
            return 0
        
        # If no child
        if not (root.left or root.right):
            return root.val if L <= root.val <= R else 0 
        
        # Check both left and right child
        if root.left and root.right:
            # Case when root value > R, then just search left child 
            if root.val > R:
                return self.rangeSumBST(root.left, L, R)
            # Case when root value < L, then just search right child 
            elif root.val < L:
                return self.rangeSumBST(root.right, L, R)
            # Otherwise, search both
            else:
                return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)
                
        # If only one child exists and root value in [L, R]
        if root.left and root.val >= L:
            return root.val + self.rangeSumBST(root.left, L, R)
        if root.right and root.val <= R:
            return root.val + self.rangeSumBST(root.right, L, R)
        else:
            return 0



1480. Running Sum of 1d Array

class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        '''
        Find the running sum of nums
        
            -type : nums (List[int])
            -rtype: List[int]
        '''
        res = nums[:]
        for i in range(1, len(res)):
            res[i] += res[i-1]
        return res



0017. Letter Combinations of a Phone Number

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        '''
        Find all possible word combinations of numbers in digits
        
            -type : digits (str)
            -rtype: List[str]        
        '''
        # Check if digits is empty
        if not digits:
            return []
        
        # Create a dictionary, d, to map int: char relationship 
        # in phon buttons
        import string
        d = {str(i):string.ascii_lowercase[(3*(i-2)):3*(i-2)+3] for i in range(2, 7)}
        d['7'] = 'pqrs'
        d['8'] = 'tuv'
        d['9'] = 'wxyz'
        
        # Use itertools to find all combinations, and reuse d as result
        from itertools import product
        from functools import reduce
        d = reduce(lambda x, y: product([''.join(ele) for ele in x], y), [list(d[i]) for i in digits])
        
        return [''.join(x) for x in d]
        
        

Day 051, 09/01/2020 Tue
Day 052, 09/02/2020 Wed

Day 053, 09/03/2020 Thu

0893. Groups of Special-Equivalent Strings

class Solution:
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        '''
        Find the number of groups of special-equivalent strings from A
        
            -type : A (List[str]) 
            -rtype: int
        '''
        # Convert all str in A to their equivalent str
        A = [self.equivalentString(s) for s in A]

        return len(set(A))
        
        
    def equivalentString(self, s: str) -> str:
        '''
        Convert s to its equivalent string, where chars in odd/even
        indices are in alphabetic orders
        
            -type : s (str)
            -rtype: str
        '''
        # Convert s to a list
        s = list(s)
        
        # Reorder s as sorted odd indexed eles + sorted even indexed eles
        s = sorted([x[1] for x in enumerate(s) if x[0]%2]) + sorted([x[1] for x in enumerate(s) if x[0]%2 == 0])
      
        return ''.join(s)
             
        
        
1413. Minimum Value to Get Positive Step by Step Sum

class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        '''
        Find the minimum positive value of startValue such that the step by step sum is never less than 1
        
            -type : nums (List[int])
            -rtype: int
        '''
        # Find the min step by step sum of nums
        minSum = currSum = nums[0]
        for i in range(1, len(nums)):
            currSum += nums[i]
            minSum = min(minSum, currSum)
        # Return max of 1 and 1 - minSum as min startValue
        return max(1, 1 - minSum)

        
        
0054. Spiral Matrix

class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        '''
        Return all elements of the matrix in spiral order.
        
            -type : matrix: List[List[int]]
            -rtype: List[int]
        '''
        # If matrix is empty, return []
        if not matrix:
            return []
        
        # Define row and column borders when moving in matrix
        r_low, r_high = 0, len(matrix)
        c_low, c_high = -1, len(matrix[0])
        
        # Define current poistion.
        i = j = 0
        
        # Define direction we move in matrix. Start with right.
        direction = 'right'
        
        # Loop  matrix in a spiral order
        res = []
        while r_low != r_high and c_low != c_high:
            if direction == 'right':
                while j < c_high:
                    res.append(matrix[i][j])
                    j += 1
                c_high -= 1
                j -= 1
                direction = 'down'
                i = min(r_high, i+1)
            elif direction == 'down':
                while i < r_high:
                    res.append(matrix[i][j])
                    i += 1
                r_high -= 1
                i -= 1
                direction = 'left'
                j = max(c_low, j-1)
            elif direction == 'left':
                while j > c_low:
                    res.append(matrix[i][j])
                    j -= 1
                c_low += 1
                j += 1
                direction = 'up'
                i = max(r_low, i-1)
            elif direction == 'up':
                while i > r_low:
                    res.append(matrix[i][j])
                    i -= 1
                r_low += 1
                i += 1
                direction = 'right'
                j = min(c_high, j+1)
            
        return res
        


Day 054, 09/04/2020 Fri
Day 055, 09/05/2020 Sat
Day 056, 09/06/2020 Sun
Day 057, 09/07/2020 Mon
Day 058, 09/08/2020 Tue


Day 059, 09/09/2020 Wed

0941. Valid Mountain Array

class Solution:
    def validMountainArray(self, A: List[int]) -> bool:
        '''
        Determine if A is a valild mountain array
        
            -type : A (List[int])
            -rtype: bool
        '''
        w = len(A)       # Define width of th mountain
        climbing = True  # Determine cuurent status: Climbing th mountain or not
        
        # Check if width of the mountain is > 3
        # And if start status is climbing the mountain
        if w < 3 or A[0] >= A[1]:
            return False
        
        # Loop the mountain startin with climbing.
        # If a flat walk found, or found a second time to climb the mountain, return False.
        # When first time see A[i-1] > A[i], convert climbing status.    
        for i in range(1, w):
            if A[i-1] == A[i] or (not climbing and A[i-1] < A[i]):
                return False
            elif climbing and A[i-1] > A[i]:
                climbing = False
        
        # If climbing is stil true at the end, then A is invalid. Otherwise, it is valid.
        return not climbing



1331. Rank Transform of an Array

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        '''
        Find rank (start from 1) of each element
        
            -type : arr (List[int])
            -rtype: List[int]
        '''
        # Use a dictionary to list rank for all unique eles
        res = {k:v for (v, k) in enumerate(sorted(set(arr)))}
        return [res[k] + 1 for k in arr]
        
        

1249. Minimum Remove to Make Valid Parentheses

class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        '''
        Remove the minimum number of parentheses to make s valid and return updated s
        
            -type: s (str)
            -rtpe: str
        '''
        # Record positions of left parentheses we see so far
        leftParentheses = []
        
        # Convert s to a list
        s = list(s)
        
        # Loop s using index.
        # If we see a left parenthesis, push its position to leftParentheses
        # If we see a right parenthesis and leftParentheses is not empty, pop leftParentheses
        # If leftParentheses is empty and we see a right parenthesis, then we need to remove this
        # right parenthesis -> convert s[i] to ''
        for i in range(len(s)):
            if s[i] == '(':
                leftParentheses.append(i)
            elif leftParentheses and s[i] == ')':
                leftParentheses.pop()
            elif s[i] == ')':
                s[i] = ''
        
        # Check if leftParentheses is empty
        # If not, we then need to convert '(' at positions in leftParentheses to ''
        if leftParentheses:
            for i in leftParentheses:
                s[i] = ''
        
        return ''.join(s)
        


Day 060, 09/10/2020 Thu

0703. Kth Largest Element in a Stream

class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        

    def add(self, val: int) -> int:
        


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)



0012. Integer to Roman

class Solution:
    def intToRoman(self, num: int) -> str:
        '''
        Convert num to a roman numeral
        
            -type : num(int)
            -rtype: str
        '''
        # Create a dictionary, d, to map integer -> Roman numeral 
        d = {1:'I', 5:'V', 10:'X', 50:'L', 100:'C', 500:'D', 1000:'M', 4:'IV', 9:'IX', 40:'XL', 90:'XC', 400:'CD', 900:'CM'}
        
        # Create a modifier and a divider, then loop num until num == 0
        # In each loop, set remainder = num%divider, and concat remainder's
        # Roman numeral conversion to res (If remainder in d, else seard remainder/(divider/10) in d)
        # and multiply divider by 10
        # Then set num = numn - remainder
        res = ''
        divider = 10
        while num > 0:
            remainder = num%divider
            if remainder and remainder in d:
                res = d[remainder] + res
            elif remainder:
                m = 10*remainder//divider
                # Need to consider case when 5, 50 and 500
                if m > 5:
                    res = d[5*divider//10] + (m-5)*d[remainder//m] + res
                else:
                    res = m*d[remainder//m] + res
            divider *= 10             
            num -= remainder 
        return res
        
        

0199. Binary Tree Right Side View



Day 061, 09/11/2020 Fri

0108. Convert Sorted Array to Binary Search Tree

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        '''
        Convert num (sorted) to a height balanced BST
        
            -type : nums (List[int])
            -rtype: TreeNode
        '''
        l = len(nums)
        
        # Check if the list is empty
        if not nums:
            return None
          
        # Set mid value as the root of the (sub)tree
        root = TreeNode(val = nums[l//2])
        
        # Check if left/right subtree shoudl exsit and set them up
        root.left = self.sortedArrayToBST(nums[:l//2]) if l//2 > 0 else None
        root.right = self.sortedArrayToBST(nums[l//2+1:]) if l/2 > 1 else None
        
        return root



0152. Maximum Product Subarray



0981. Time Based Key-Value Store



Day 062, 09/12/2020 Sat
Day 063, 09/13/2020 Sun



Day 064, 09/14/2020 Mon

0170. Two Sum III - Data structure design

class TwoSum:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = {}
        

    def add(self, number: int) -> None:
        """
        Add the number to an internal data structure..
        """
        if number in self.d:
            self.d[number] += 1
        else:
            self.d[number] = 1

    def find(self, value: int) -> bool:
        """
        Find if there exists any pair of numbers which sum is equal to the value.
        """
        for k in self.d:
            if value - k in self.d and (value - k != k or (value == 2*k and self.d[k] > 1)):
                return True  
        
        return False


0064. Minimum Path Sum



0347. Top K Frequent Elements

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        '''
        Find the top K mist frequent ele in nums
            
            -types: nums (List[int])
                       k (int)
            -rtype: List[int]
        '''
        # Use Counter
        from collections import Counter
        nums = Counter(nums)
        nums = nums.most_common(k)
        return [x[0] for x in nums]        




Day 065, 09/15/2020 Tue


Day 066, 09/16/2020 Wed

0687. Longest Univalue Path


        
0078. Subsets

class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        '''
        Find all possible nums' subsets
            
            - type : nums (List[int])
            - rtype: List[List[int]
        '''
        # Initiate result, res, from a list contains only empty set
        res = [[]]
        
        # Case when nums is empty
        if not nums:
            return res
        
        # Use itertools.combinations to find all required subsets
        from itertools import combinations
        for i in range(1, len(nums)):
            res.extend([list(x) for x in combinations(nums, i)])
        
        # Include nums itself in the end
        res.append(nums)
        return res



1262. Greatest Sum Divisible by Three

class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        '''
        Find the maximum possible sum of elements of the array such that it is divisible by 3.

            -type : nums (List[int])
            -rtype: int
        '''
        # Create a list, res, with length = length of nums.
        # Each ele in res is a list, where index of each ele
        # will record current largest sum that mod 3 = index
        res = [[0, 0, 0] for _ in range(len(nums))]
        res[0][nums[0]%3] = nums[0]
        
        # Loop nums and find max of current sum where mod 3 = 0, 1 or 2, based on previous sums and current ele.
        for i in range(1, len(nums)):
            for j in range(3):
                temp = [nums[i]+x for x in res[i-1] if (nums[i]+x)%3 == j]
                res[i][j] = max(max(temp), res[i-1][j]) if temp else res[i-1][j]
          
        return res[-1][0]



Day 067, 09/17/2020 Thu



Day 068, 09/18/2020 Fri

0704. Binary Search

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        '''
        Find index of target in nums (sorted) if it exists. Otherwise, -1
        
            -type : nums   (List[int]) 
                    target (int)
            -rtype: int
        '''
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right)//2
            
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
            
        return -1



0646. Maximum Length of Pair Chain

class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
             





0148. Sort List

class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        




Day 069, 09/19/2020 Sat
Day 070, 09/20/2020 Sun

1118. Number of Days in a Month

class Solution:
    def numberOfDays(self, Y: int, M: int) -> int:
        '''
        Find how many days there are in year Y and a month M
        
            -type : Y (int) 
                    M (int)
            -rtype: int
        '''
        # For big months,
        if M in [1,3,5,7,8,10,12]:
            return 31
        # for samll months, except Feb
        elif M in [4,6,9,11]:
            return 30
        elif Y%400 == 0 or (Y%4 == 0 and Y%100 != 0):
            return 29
        else:
            return 28
            
        

0636. Exclusive Time of Functions

                    
                    
0987. Vertical Order Traversal of a Binary Tree

class Solution:
    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
       



Day 071, 09/21/2020 Mon

1544. Make The String Great

class Solution:
    def makeGood(self, s: str) -> str:
        '''
        Find the string after making it good. 
        
            -type : s (str)
            -rtype: str
        '''
        # Loop s.
        # Using a stack to hold each ele.
        # Once find current ele = last ele in stack after
        # lower/upper conversion, pop stack.
        stack = []
        for x in s:
            if stack and x.islower() == stack[-1].isupper() and x.lower() == stack[-1].lower():
                stack.pop()   
            else:
                stack.append(x)

        # Return ele in stack in the form of a list
        return ''.join(stack)        



0300. Longest Increasing Subsequence

0767. Reorganize String


Day 072, 09/22/2020 Tue
Day 073, 09/23/2020 Wed
Day 074, 09/24/2020 Thu
Day 075, 09/25/2020 Fri
Day 076, 09/26/2020 Sat
Day 077, 09/27/2020 Sun


Day 078, 09/28/2020 Mon

0111. Minimum Depth of Binary Tree

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        '''
        Find minimum depth in the tree.
        
            -type : root (TreeNode) 
            -rtype: int
        '''
        
        def traverseTree(root: TreeNode) -> int:
            if not root:
                return 0
            elif not (root.left or root.right):
                return 1
            elif root.left and not root.right:
                return 1 + traverseTree(root.left)
            elif not root.left and root.right:
                return 1 + traverseTree(root.right)
            else:
                return 1 + min(traverseTree(root.left), traverseTree(root.right))     
        
        return traverseTree(root)



0018. 4Sum       

0692. Top K Frequent Words

class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        '''
        Find the k most frequent elements.
        
            -types: words (List[str]) 
                        k (int)
            -rtype: List[str]
        '''
        # Use counter to count and sort words by frequency
        from collections import Counter
        words = Counter(words)
        words = words.most_common()
        
        # Find the top K
        # In case same freqs occur, need to order words in this case alphabetically
        res = []
        i, l = 0, len(words)
        while i < k and i < l:
            temp = []
            while i < l-1 and words[i][1] == words[i+1][1]:
                temp.append(words[i][0])
                i += 1
            temp.append(words[i][0])
            temp.sort()
            res.extend(temp)             
            i += 1

        return res[:k]



Day 079, 09/29/2020 Tue


Day 080, 09/30/2020 Wed

0257. Binary Tree Paths

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root:
            return []
        appendix = self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)
        return [str(root.val) + '->' + str(x) for x in appendix] if appendix else [str(root.val)]



class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        width = len(matrix)
        ru, rd = 0, width-1
        cl, cr = 0, width-1
        
        # Rotate one by one from outmost circle to innermost circle
        while width > 1:
            for i in range(width-1):    
                temp, matrix[ru+i][cr] = matrix[ru+i][cr] ,matrix[ru][cl+i]
                temp, matrix[rd][cr-i] = matrix[rd][cr-i], temp
                temp, matrix[rd-i][cl] = matrix[rd-i][cl], temp
                matrix[ru][cl+i] = temp
  
            ru += 1
            rd -= 1
            cl += 1
            cr -= 1
            width -= 2



Day 081, 10/01/2020 Thu

0287. Find the Duplicate Number

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        '''
        Find the only duplicate in nums
        
            -  type: nums (List[int])
            - rtype: int 
        '''
        # Sort nums
        nums.sort()
        
        # Loop nums from the start and once nums[i-1] == nums[i],
        # return nums[i]
        for i in range(1, len(nums)):
            if nums[i-1] == nums[i]:
                return nums[i]



Day 082, 10/02/2020 Fri

1351. Count Negative Numbers in a Sorted Matrix

0974. Subarray Sums Divisible by K

1048. Longest String Chain



Day 083, 10/03/2020 Sat
Day 084, 10/04/2020 Sun
Day 085, 10/05/2020 Mon
Day 086, 10/06/2020 Tue
Day 087, 10/07/2020 Wed



Day 088, 10/08/2020 Thu

0110. Balanced Binary Tree

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:



0540. Single Element in a Sorted Array

class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        '''
        Find the only non duplicate in nums
        
            - type: nums (List[int])
            -rtype: int
        '''
        # Use exclusive OR in bit operation
        from functools import reduce
        return reduce(lambda x, y: x ^ y, nums)


Day 089, 10/09/2020 Fri

1550. Three Consecutive Odds

class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        '''
        Determine if there are 3 consecutive odd numbers in arr
            
            - type: arr(List[int])
            -rtype: bool
        '''
        # Create a variable, consective_odds, to record consecutive odd numbers.
        # Loop arr. If see an even number, set consective_odds = 0.
        # Else, consective_odds + 1.
        # Return True if consective_odds == 3
        consective_odds = 0
        
        i, l = 0, len(arr)
        
        while i < l:
            consective_odds = consective_odds + 1 if arr[i]%2 else 0
            if consective_odds == 3:
                return True
            i += 1



0946. Validate Stack Sequences

class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        '''
        Determine if pushed and popped could be valid operations of a stack
        
            -types: pushed (List[int]) 
                    popped (List[int])
            -rtype: bool
        '''
        # Create a stack to mock operations in pushed and popped.
        # In parallel, use two pointers, i and j, to loop eles in 
        # pushed and popped.
        stack = []
        i = j = 0
        l_pushed, l_popped = len(pushed), len(popped)
        
        while i != l_pushed or j != l_popped:
            if i < l_pushed:
                stack.append(pushed[i])
                while stack and stack[-1] == popped[j]:
                    stack.pop()
                    j += 1
                i += 1
            elif stack and stack[-1] == popped[j]:
                stack.pop()
                j += 1
            else:
                return False

        return stack == []



Day 090, 10/10/2020 Sat
Day 091, 10/11/2020 Sun
Day 092, 10/12/2020 Mon
Day 093, 10/13/2020 Tue


Day 094, 10/14/2020 Wed

0543. Diameter of Binary Tree

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        '''
        Find the length of the diameter of the tree. 
        
            -type : root (TreeNode)
            -rtype: int
        '''
        
        def maxDepth(root: TreeNode) -> int:
            '''
            Find the length max depth the tree. 

                -type : root (TreeNode)
                -rtype: int            
            '''
            if not (root and (root.left or root.right)):
                return 0
            else:
                return 1 + max(maxDepth(root.left), maxDepth(root.right))
            
        if not root or not (root.left or root.right):
            return 0
        elif root.left and not root.right:
            return 1 + maxDepth(root.left)
        elif not root.left and root.right:
            return 1 + maxDepth(root.right)
        else:
            return 2 + maxDepth(root.left) + maxDepth(root.right)



1523. Count Odd Numbers in an Interval Range

class Solution:
    def countOdds(self, low: int, high: int) -> int:
        '''
        Find the count of odd numbers between low and high (inclusive)
        
            -types: low  (int)
                    high (int)
            -rtype: int
        '''
        return (high - low + 1)//2 + ((high - low + 1)%2) * (low%2)


Day 095, 10/15/2020 Thu
Day 096, 10/16/2020 Fri

0200. Number of Islands



Day 097, 10/17/2020 Sat
Day 098, 10/18/2020 Sun
Day 099, 10/19/2020 Mon
Day 100, 10/20/2020 Tue
Day 101, 10/21/2020 Wed
Day 102, 10/22/2020 Thu
Day 103, 10/23/2020 Fri
Day 104, 10/24/2020 Sat
Day 105, 10/25/2020 Sun



Day 106, 10/26/2020 Mon

0892. Surface Area of 3D Shapes
            

0209. Minimum Size Subarray Sum

class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        '''
        Find the minimal length of a contiguous subarray of which the sum ≥ s
            
            -types:    s (int)
                    nums (List[int])    
            -rtype: int
        '''
        # Find length of nums
        l = len(nums)
        
        # Initiate result, subSum btw two pointers and start and end pointers
        subSum = nums[0]
        if subSum >= s:
            res = 1
            start = end = 0
        else:
            res = l
            start, end = 0, 1
        
        # Loop nums
        while start <= end or end < l: 
            if subSum < s:
                end += 1
                subSum += nums[end]
            else:
                res = min(res, end - start + 1)
                subSum -= nums[start]
                if start == end:
                    end += 1
                end = min(l-1, end)
                start += 1

        return res



Day 107, 10/27/2020 Tue



Day 108, 10/28/2020 Wed

0141. Linked List Cycle

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        '''
        Determine if head has a cycle
        
            -type : head (ListNode)
            -rtype: bool
        '''
        # Use a slow and a fast pointers to traverse the list.
        # If the two pointers meet, there is a cycle. Otherwise, no.
        slow = head if head else None
        slow = head if head else None
        slow = head if head else None
        fast = head.next.next if head and head.next else None
        
        while slow and fast:
            if slow and fast and slow.val == fast.val:
                return True
            slow = slow.next
            fast = fast.next.next if fast and fast.next else None
        return False



1022. Sum of Root To Leaf Binary Numbers

   

Day 109, 10/29/2020 Thu
Day 110, 10/30/2020 Fri
Day 111, 10/31/2020 Sat
Day 112, 11/01/2020 Sun


Day 113, 10/02/2020 Mon

0235. Lowest Common Ancestor of a Binary Search Tree

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        '''
        Find the lowest common ancestor of p and q.
        
            -types: p (TreeNode)
                    q (TreeNode)
            -rtype: TreeNode
        '''
        # Make the node that has smaller value as p
        if p.val > q.val:
            p, q = q, p
            
        # Check if p and q are on different sides of root
        # If yes, then return root
        if p.val <= root.val <= q.val:
            return root
        # Otherwise, recursively use this func on 
        # either left/right side of the root
        elif q.val <= root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        else:
            return self.lowestCommonAncestor(root.right, p, q)



0276. Paint Fence



0621. Task Scheduler
       


Day 114, 10/03/2020 Tue



Day 115, 10/04/2020 Wed

1640. Check Array Formation Through Concatenation

class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        '''
        Determine if arr can be formed by concatenating arrays in pieces.
        
            -types:    arr (List[int])
                    pieces (List[List[int]])
            -rtype: bool
        '''
        # An indictor to determine if such an ele in arr can be found in pieces
        found = True
        
        # Loop pieces and find if any piece can be found in arr
        # If not, the return False
        while pieces and found:
            found = False
            for i in range(len(arr)):
                if pieces[-1][0] == arr[i]:
                    found = True
                    if arr[i:i+len(pieces[-1])] != pieces[-1]:
                        print(arr[i:i+len(pieces[-1])] == pieces[-1])
                        return False
            pieces.pop()
        
        # Return True if all pieces can be found in arr, otherwise, False. 
        return True if found else False
        
        

1641. Count Sorted Vowel Strings



0033. Search in Rotated Sorted Array

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        '''
        Find index of target in nums, where nums might be rotated beforehand.
        
            -types:   nums (List[int)
                    target (int)
            -rtype: int
        '''
        import bisect
        # Case when only 1 ele in nums
        if nums[0] == nums[-1]:
            return 0 if nums[0] == target else -1

        # Case when nums is sorted and target is out of range of nums,
        # then return -1
        elif nums[0] < nums[-1] and (target > nums[-1] or target < nums[0]):
            return -1
        
        # Case when nums is sorted, then do a binary search to find if ele of 
        # that index is target
        elif nums[0] < nums[-1]:
            index = bisect.bisect_left(nums, target)
            return index if nums[index] == target else -1
        
        # Case when nums is not sorted, and target > nums[-1] and target < nums[0],
        # then just return -1
        elif target > nums[-1] and target < nums[0]:
            return -1
            
        # Else, find the original pivot,
        # and find which part target could be in and use binart search to find if target is in nums            
        elif target <= nums[-1]:
            pivot_index = nums.index(min(nums))
            index = bisect.bisect_left(nums[pivot_index:], target)
            return index+pivot_index if nums[index+pivot_index] == target else -1
        elif target >= nums[0]:
            pivot_index = nums.index(max(nums))
            index = bisect.bisect_left(nums[:pivot_index], target)
            return index if nums[index] == target else -1



Day 116, 10/05/2020 Thu


0160. Intersection of Two Linked Lists

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        '''
        Find the node at which the intersection of two singly linked lists begins
        
            -types: headA (Node)
                    headA (Node)
            -rtype: Node
        '''
        # Case when either one is null
        if not (headA and headB):
            return None
        
        # Define two pointer nodes starting from A (pA) and B (pB)
        pA, pB = headA, headB
        
        # Loop both pA and pB
        # If pA/pB fully looped, then switch it to pB/pA, and let switched + 0.5
        # when both pA/pB fully looped.
        # If switched and pA/pB fully looped again (switched > 1) but still no intersection nodes
        # found, then return None. Else, return the intersection node.
        switched = 0
        while switched <= 1:
            if not pA:
                switched += 0.5
                pA = headB
            elif not pB:
                switched += 0.5
                pB = headA
            elif pA != pB:
                pA, pB = pA.next, pB.next
            else:
                return pA
        return None



0767. Reorganize String
     


0957. Prison Cells After N Days

class Solution:
    def prisonAfterNDays(self, cells: List[int], N: int) -> List[int]:
        '''
        Find the state of cells after N days.
        
            -types: cells (List[int])
                        N (int)
            -rtype: List[int]
        '''
        for x in range(N):
            old_cells = cells
            cells = [old_cells[0]] + [1 if old_cells[i-1] == old_cells[i+1] else 0 for i in range(1, 7)] + [old_cells[-1]]
        return cells



Day 117, 10/06/2020 Fri

0993. Cousins in Binary Tree


Day 118, 10/07/2020 Sat
Day 119, 10/08/2020 Sun


Day 120, 11/09/2020 Mon

1252. Cells with Odd Values in a Matrix

class Solution:
    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:    
        res = [[0 for _ in range(m)] for _ in range(n)]
        for x, y in indices:
            res[x] = [1-res[x][j] for j in range(m)]
            for i in range(n):
                res[i][y] = 1-res[i][y]
        
        return sum([sum(res[i]) for i in range(n)])


Day 120, 11/09/2020 Mon
Day 121, 11/10/2020 Tue
Day 122, 11/11/2020 Wed
Day 123, 11/12/2020 Thu
Day 124, 11/13/2020 Fri
Day 125, 11/14/2020 Sat
Day 126, 11/15/2020 Sun
Day 127, 11/16/2020 Mon
Day 128, 11/17/2020 Tue
Day 129, 11/18/2020 Wed
Day 130, 11/19/2020 Thu
Day 131, 11/20/2020 Fri
Day 132, 11/21/2020 Sat
Day 133, 11/22/2020 Sun
Day 134, 11/23/2020 Mon
Day 135, 11/24/2020 Tue
Day 136, 11/25/2020 Wed
Day 137, 11/26/2020 Thu
Day 138, 11/27/2020 Fri
Day 139, 11/28/2020 Sat
Day 140, 11/29/2020 Sun



Day 141, 11/30/2020 Mon

0647. Palindromic Substrings

class Solution:
    def countSubstrings(self, s: str) -> int:
        '''
        Find how many palindromic substrings in s.
        
            -type : s (str)
            -rtype: int 
        '''
        # Initiate result, res, as length of s, since
        # every char in s is palindromic
        res = l = len(s)
        
        # Check palindromic substrings with odd length and length > 1
        # Loop from the 1st index (0-indexed). Check if chars with same
        # distance to current char are equal
        for i in range(1, l-1):
            isPalindromic = True
            currDist = 1
            furthestDist = min(i, l-1-i) 
            
            while isPalindromic and currDist <= furthestDist:
                isPalindromic = s[i-currDist] == s[i+currDist]
                res += 1*isPalindromic
                currDist += 1
               
        # Check palindromic substrings with even length and length > 1
        # Loop from index 0. Check if the next char is equal to current char.
        # If yes, check the left char with same distance to current char and
        # the right char with same distance to the next char are equal
        for i in range(l-1):
            isPalindromic = True
            currDist = 1
            furthestDist = min(i, l-1-i-1) 
            
            if s[i] == s[i+1]:
                res += 1
                while isPalindromic and currDist <= furthestDist:
                    isPalindromic = s[i-currDist] == s[i+1+currDist]
                    res += 1*isPalindromic
                    currDist += 1
        
        return res
       

The Skyline Problem



Day 142, 12/01/2020 Tue



Day 143, 12/02/2020 Wed

Shortest Word Distance

class Solution:
    def shortestDistance(self, words: List[str], word1: str, word2: str) -> int:
        '''
        Find the shortest distance btw word1 and word2
        
            -types: words (List[str])
                    word1 (str)
                    word2 (str)
            -rtype: int
        '''
        index1 = index2 = None
        res = len(words)
        
        for i in range(len(words)):
            if words[i] == word1:
                index1 = i
            elif words[i] == word2:
                index2 = i
            
            if index1 != None and index2 != None:
                res = min(res, abs(index2 - index1))
        return res



Linked List Random Node

class Solution:

    def __init__(self, head: ListNode):
        """
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """
        self.head = head
        self.l = 0
        while head:
            self.l += 1
            head = head.next
        

    def getRandom(self) -> int:
        """
        Returns a random node's value.
        """
        import random
        r = random.randint(1, self.l)

        temp = self.head
        res = temp.val
        i = 1
        while i < r:
            temp = temp.next
            res = temp.val
            
            i += 1
        return res



0152. Maximum Product Subarray



Day 144, 12/03/2020 Thu

0039. Combination Sum   

0624. Maximum Distance in Arrays

class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        currMin = min(arrays[0])
        currMax = max(arrays[1])
        res = currMax - currMin
        
        for i in range(2, len(arrays)):
            res = max(currMax - min(arrays[i]), -currMin + max(arrays[i]), res)
            
            if max(arrays[i]) > currMax:
                currMax = max(arrays[i])
            elif currMin > min(arrays[i]):
                currMin = min(arrays[i])
        
        currMin = min(arrays[1])
        currMax = max(arrays[0])
        res = max(res, currMax - currMin)
        print(currMin, currMax)
        for i in range(2, len(arrays)):
            res = max(currMax - min(arrays[i]), -currMin + max(arrays[i]), res)
            
            if max(arrays[i]) > currMax:
                currMax = max(arrays[i])
            elif currMin > min(arrays[i]):
                currMin = min(arrays[i])
        
        return res



Day 145, 12/04/2020 Fri

The kth Factor of n

class Solution:
    def kthFactor(self, n: int, k: int) -> int:
        '''
        Find the kth factor in this list or return -1 if n has less than k factors.
        
            -types: n (int)
                    k (int)
            -rtype: int
        '''
        # Find all factors of n by looping from 1 to n
        # Once the pointer == k, return current factor
        # If after looping all n numbers, k > pointer, return -1 
        if k == 1:
            return 1
        
        nth_factor = curr_factor = 1
        for i in range(2, n+1):
            if n%i == 0:
                nth_factor += 1
                curr_factor = i
            
            if k == nth_factor:
                return curr_factor 
        
        return -1



1041. Robot Bounded In Circle



Day 146, 12/05/2020 Sat


Day 147, 12/06/2020 Sun

class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        

0086. Partition Listclass Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        # Initiate result, res (a linked list), to gather all nodes
        # with val < x in the original relative order  before seeing
        # the first Node with val >= x
        res = head if head and head.val < x else None
        res0 = res
        head = head.next if head and res else head
        
        # Gather all nodes with val < x before observing
        # any node that has val >= x
        while head and head.val < x:
            res.next = head       
            res = res.next
            head = head.next
        
        
        # Loop the remaining part
        # If node has val >= x, then move to next nodes
        # until a node, n, has val < x is found and then 
        # append n to res and append other part to n
        # Append remaining parts if no node has val < x
        temp = head
        while temp and temp.next:
            if temp.next.val >= x:
                temp = temp.next
            elif temp.next.val < x and res:
                res.next = temp.next
                res = res.next
                temp.next = temp.next.next
            else:
                res = temp.next
                res0 = res
                temp.next = temp.next.next

        print()
        if res:
            res.next = head
        if not res and head:
            return head
        
        return res0



Day 148, 12/07/2020 Mon

0059. Spiral Matrix II

class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        '''
        Generate an n x n matrix filled with elements from 1 to n^2 in spiral (clockwise) order.
        
            -type : n (int)
            -rtype: List[List[int]]
        '''
        # Initiate result, res
        res = [[None for _ in range(n)] for _ in range(n)]
        
        # Define some metrics when creating the spiral matrix
        totalNumToFill = n  # Total number of elements to fill in row/column based on current status
        currNumToFill = n   # Current number of elements to fill in current row/column
        timesLeft = 1       # Number of total times left to before decrementing totalNumToFill
        direction = 0       # Direction to go: 0 (right), 1 (down), 2 (left), 3 (up). Start with right.
        i = j = 0           # Pointers (i: row, j: column) to indicate coordinates of current position in res
        
        # Loop the matrix (res) in a spiral order
        for x in range(n*n):
            # Assign new value to current position
            res[i][j] = x + 1
            # Decrement numToFill
            currNumToFill -= 1
            
            # Determine next location
            if direction == 0 and currNumToFill:
                j += 1
            elif direction == 0 and currNumToFill == 0:
                i += 1
                direction = 1
            elif direction == 1 and currNumToFill:
                i += 1
            elif direction == 1 and currNumToFill == 0:
                j -= 1
                direction = 2
            elif direction == 2 and currNumToFill:
                j -= 1
            elif direction == 2 and currNumToFill == 0:
                i -= 1 
                direction = 3
            elif direction == 3 and currNumToFill:
                i -= 1
            elif direction == 3 and currNumToFill == 0:
                j += 1 
                direction = 0
            
            # Check if need to update currNumToFill and totalNumToFill
            if currNumToFill == 0:
                timesLeft -= 1
                
                if timesLeft == 0:
                    timesLeft = 2
                    totalNumToFill -= 1
                currNumToFill = totalNumToFill

        return res



1046. Last Stone Weight

0399. Evaluate Division



Day 149, 12/08/2020 Tue
Day 150, 12/09/2020 Wed
Day 151, 12/10/2020 Thu
Day 152, 12/11/2020 Fri
Day 153, 12/12/2020 Sat
Day 154, 12/13/2020 Sun
Day 155, 12/14/2020 Mon
Day 156, 12/15/2020 Tue
Day 157, 12/16/2020 Wed
Day 158, 12/17/2020 Thu
Day 159, 12/18/2020 Fri
Day 160, 12/19/2020 Sat
Day 161, 12/20/2020 Sun
Day 162, 12/21/2020 Mon
Day 163, 12/22/2020 Tue
Day 164, 12/23/2020 Wed
Day 165, 12/24/2020 Thu
Day 166, 12/25/2020 Fri
Day 167, 12/26/2020 Sat
Day 168, 12/27/2020 Sun



Day 169, 12/28/2020 Mon

1502. Can Make Arithmetic Progression From Sequence

class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        '''
        Determine if arr can be rearranged to form an arithmetic progression.
        
            -type : arr (List[int])
            -rtype: bool
        '''
        # Sort arr
        arr.sort()
        
        # Determine if rearranged an arithmetic progression.
        return all([abs(arr[i] - arr[i-1]) == abs(arr[0] - arr[1]) for i in range(1, len(arr))])
        


0721. Accounts Merge

Challenge. Reach a Number



Day 170, 12/29/2020 Tue


Day 171, 12/30/2020 Wed

Challenge

Longest Substring with At Most K Distinct Characters

class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        '''
        Find the length of the longest substring with at most K distinct chars.
        
            -types: s (str)
                    k (int)
            -rtype: int
        '''
        # Special case when k is 0
        if k == 0:
            return 0
        
        max_len = curr_len = 1
        num_of_distinct = 1
        distinct_chars = {s[0]: 1}
        i, j, l = 0, 1, len(s)
        
        # Loop s.
        # If adding current char is not making num_of_distinct > k, then curr_len + 1 and j + 1
        # Else, remove the first char of the substring and increment the substring start index
        while j < l:
            if num_of_distinct < k:
                if s[j] in distinct_chars:
                    distinct_chars[s[j]] += 1
                else:
                    distinct_chars[s[j]] = 1
                    num_of_distinct += 1
                curr_len += 1
                j += 1
            
            elif s[j] in distinct_chars:
                distinct_chars[s[j]] += 1
                curr_len += 1
                j += 1
                
            else:
                distinct_chars[s[i]] -= 1
                if distinct_chars[s[i]] == 0:
                    num_of_distinct -=  1
                    del distinct_chars[s[i]]
                i += 1
                curr_len -= 1
            
            max_len = max(max_len, curr_len)
            print(max_len, curr_len, num_of_distinct)
        return max_len



1033. Moving Stones Until Consecutive

class Solution:
    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:
        '''
        Find the min and maxm number of moves that can make positions consecutive
        
            -types: a (int)
                    b (int)
                    c (int)
            -rtype: List[int]
        '''
        # Create a list to make a, b and c sorted
        l = sorted([a, b, c])
        
        # Case when l is consective
        if l[0] + 1 == l[1] and l[1] + 1 == l[2]:
            return [0, 0]
        
        # Case when delta btw one neighbor is 1 and the other is 2
        if (l[0] + 1 == l[1] and l[1] + 2 == l[2]) or (l[0] + 2 == l[1] and l[1] + 1 == l[2]):
            return [1, 1]

        # Case when delta btw 2 neighbors is 2
        if l[0] + 2 == l[1] and l[1] + 2 == l[2]:
            return [1, 2]

        # Case when there is only 1 neighbored pair that delta = 1
        if l[0] + 1 == l[1]:
            return [1, l[2]-l[1]-1]
        if l[1] + 1 == l[2]:
            return [1, l[1]-l[0]-1]
            
        # Case when there is only 1 neighbored pair that delta = 2
        if l[0] + 2 == l[1]:
            return [1, l[2]-l[1]]
        if l[1] + 2 == l[2]:
            return [1, l[1]-l[0]]
            
        # Other cases
        return [2, l[1]-l[0]-1+l[2]-l[1]-1]



Day 172, 12/31/2020 Thu
Day 173, 01/01/2021 Fri
Day 174, 01/02/2021 Sat
Day 175, 01/03/2021 Sun


Day 176, 01/04/2021 Mon

0050. Pow(x, n)

class Solution:
    def myPow(self, x: float, n: int) -> float:
        '''
        Calculates x raised to the power n 
        
            -types: x (float)
                    n (int)
            -rtype: float
        '''
        from functools import reduce
        # Case when x is 0 or 1
        if x == 0 or x == 1:
            return x
        
        # Case when x is -1
        if x == -1:
            return (-1) ** (abs(n)%2)
        
        # Case when n is 0
        if n == 0:
            return 1.0000     
        
        res = 1
        cnt = 0
        # Case when n > 0
        if n > 0:
            while cnt < abs(n) and abs(round(res, 6)) > 0:
                res *= x
                cnt += 1

        # Case when n < 0
        if n < 0:
            while cnt < abs(n) and abs(round(res, 6)) > 0:
                res *= 1/x
                cnt += 1
            
        return round(res, 6)



Day 177, 01/05/2021 Tue



Day 178, 01/06/2021 Wed

1048. Longest String Chain

Day 179, 01/07/2021 Thu
Day 180, 01/08/2021 Fri
Day 181, 01/09/2021 Sat
Day 182, 01/10/2021 Sun
Day 183, 01/11/2021 Mon
Day 184, 01/12/2021 Tue



Day 185, 01/13/2021 Wed

Boats to Save People   



0637. Average of Levels in Binary Tree

class Solution:
    def averageOfLevels(self, root: TreeNode) -> List[float]:
        '''
        Find the average value of the nodes on each level of root.
        
            -type : root (TreeNode)
            -rtype: List[float]
        '''
        if not root: return []
        
        stack = [root]
        storage = []
        currSum = currCnt = 0
        res = []
        
        # Loop one level and find all values and take average to append to res 
        while stack:
            while stack:
                temp = stack.pop()
                      
                currSum += temp.val
                currCnt += 1
                
                # Only include non-empty children
                if temp.left:
                    storage.append(temp.left)
                if temp.right:
                    storage.append(temp.right)  
            
            # Calculating average for this level
            if currCnt:
                res.append(currSum/currCnt)
            
            # Reset values
            stack = storage
            storage = []
            currSum = currCnt = 0
            
        return res 



0139. Word Break



Day 186, 01/14/2021 Thu

Minimum Operations to Reduce X to Zero

0276. Paint Fence

1423. Maximum Points You Can Obtain from Cards

class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        '''
        Find the maximum score you can obtain

            -types: cardPoints (List[int])
                             k (int)
            -rtype: int
        '''
        l = len(cardPoints)
        
        # Special cases
        # 1. l == k
        if l == k:
            return sum(cardPoints)
        # 2. k is 1
        if k == 1:
            return max(cardPoints[0], cardPoints[-1])
        
        # Initiate two pointers to loop cardPoints from both ends, with assuming to start with
        # taking k cards from the left, and then removing rightmost card on the left part and taking
        # one card from the right part, until no cards left in the left part.
        # In this process, dynamically recording max points.
        i, j = k-1, l-1
        maxPoints = currPoints = sum(cardPoints[:k])
        while i >-1:
            currPoints = currPoints - cardPoints[i] + cardPoints[j]
            i -= 1
            j -= 1
            maxPoints = max(maxPoints, currPoints)
        
        return maxPoints
            
        
        


Day 187, 01/15/2021 Fri

Get Maximum in Generated Array

class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        '''
        Find the max of th generated array
        
            -type : n (int)
            -rtype: int
        '''
        # Cases when n is 0
        if n == 0:
            return 0
        
        # Initiate the result array, and a variable t remember max
        res = [0]*(n + 1)
        res[1] = 1
        maxNum = 1
        
        for i in range(2, n+1):
            res[i] = res[i//2] if i%2 == 0 else res[(i-1)//2] + res[(i-1)//2+1]
            maxNum = max(maxNum, res[i])
        
        return maxNum



1708. Largest Subarray Length K

class Solution:
    def largestSubarray(self, nums: List[int], k: int) -> List[int]:
        '''
        Find the largest subarray of nums of length k
           
            -types: nums (List[int])
                       k (int)
            -rtype: List[int]
        '''
        # Since elements in nums are all distinct, just find where max of
        # nums[:len(nums)-k+1] and the result array will be nums[maxPos:(maxPos+k)]
        maxPos = max(nums[:len(nums)-k+1])
        maxPos = nums.index(maxPos)
        
        return nums[maxPos:(maxPos+k)]



0987. Vertical Order Traversal of a Binary Tree

1428. Leftmost Column with at Least a One



Day 188, 01/16/2021 Sat
Day 189, 01/17/2021 Sun
Day 190, 01/18/2021 Mon
Day 191, 01/19/2021 Tue
Day 192, 01/20/2021 Wed

Day 193, 01/21/2021 Thu

0523. Continuous Subarray Sum

1583. Count Unhappy Friends

1673. Find the Most Competitive Subsequence



Day 194, 01/22/2021 Fri

One Edit Distance

class Solution:
    def isOneEditDistance(self, s: str, t: str) -> bool:
        '''
        Determine if s and t are both one edit distance apart, 
           
           -types: s (str)
                   t (str)
           -rtype: bool
        '''
        # Special case if both s and t are empty, then return false
        if not (s or t):
            return False
        
        # Keep removing chars one by one from the start of both s and t as long as
        # current elements of s and t are the same
        while s and t and s[0] == t[0]:
            s = s[1:]
            t = t[1:]
        
        # Keep removing chars one by one from the end of both s and t as long as
        # current elements of s and t are the same
        while s and t and s[-1] == t[-1]:
            s = s[:-1]
            t = t[:-1]
        
        # Determine if both s and t have length = 1, or just one has length = 1
        return (len(s) == 1 and len(t) == 1) or (len(s) == 0 and len(t) == 1) or (len(s) == 1 and len(t) == 0)



0539.Minimum Time Difference  

class Solution:
    def findMinDifference(self, timePoints: List[str]) -> int:
        '''
        Find the min time difference between any two time elements in timePoints
        
            -type : timePoints (List[str])
            -rtype: int
        '''
        # Sort timePoints
        timePoints.sort()
        
        # Define a function, diffMin, to determine time difference, in minute, between two time-points
        def diffMin(t1: str, t2: str) -> int:
            '''
            Find time difference (in minute) between t1 and t2
            
                -types: t1 (str)
                        t2 (str)
                -rtype: int
            '''
            # Split t1 and t2 to lists in format of ["HH", "MM"]
            t1 = t1.split(':')
            t2 = t2.split(':')
            
            # Find difference of HH and MM part
            h = int(t1[0]) - int(t2[0])
            m = int(t1[1]) - int(t2[1])
            
            # Convert h to positive and then m to minute diff btw t1 and t2
            h = 24 + h if h < 0 else h
            m = abs(60*h + m)
            
            # return min of m and 24*60-m
            return min(m, 24*60-m)
            
        # Loop timePoints and find min diff btw any two time-points
        res = 60*24
        for i in range(len(timePoints)):
            res = min(res, diffMin(timePoints[i-1], timePoints[i]))
        
        return res
        


0547. Number of Provinces

class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        '''
        Find the number of provinces based on the connection board
        
            -type : isConnected (List[List[int]])
            -rtype: int
        '''
        # Create a board, visited, that has the same size as isConnected, to 
        # record positions visited
        num_of_prov = len(isConnected)
        self.visited = [False for _ in range(num_of_prov)]
        
        # Create a dictionary to record connected positions for each position
        # Loop isConnected. If a 1 is seen, record this connected position in connection
        self.connection = {}
        for i in range(num_of_prov):
            for j in range(num_of_prov):
                if i in self.connection and isConnected[i][j] :
                    self.connection[i].add(j)
                elif isConnected[i][j]:
                    self.connection[i] = set([j])

        # Initiate result, number of connected province group(s)
        res = 0

        def findAllConnected(i: int) -> None:
            '''
            Find all connected positions and mark them as visited
            
                -type : i (int)
                -rtype: None
            '''
            # Mark current position as visited
            self.visited[i] = True
            
            for x in self.connection[i]:
                if not self.visited[x] and i != x:
                    findAllConnected(x)
            return
        
        # Loop each position and mark their connected position(s)
        for i in range(num_of_prov):
            if not self.visited[i]:
                res += 1        
                findAllConnected(i)

        return res



Day 195, 01/23/2021 Sat

Day 196, 01/24/2021 Sun

Merge k Sorted Lists

class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        '''
        Merge k linked-lists lists, each in ascending order) into one sorted linked-list
        
            - type: lists (List[ListNode])
            -rtype: ListNode
        '''
        # Create a dict to find frequency of nodes with different values
        d = {}
        
        for l in lists:
            while l:
                if l.val in d:
                    d[l.val] += 1
                else:
                    d[l.val] = 1
                l = l.next
        
        # Sort keys of d in ascending order, and append d[key] nodes with val = key to res0
        keys = sorted(d.keys())
        
        res0 = res = ListNode()
        
        for k in keys:
            for i in range(d[k]):
                res0.next = ListNode(k)
                res0 = res0.next
        res = res.next
        
        return res



0207. Course Schedule

0279. Perfect Squares

class Solution:
    def numSquares(self, n: int) -> int:
        '''
        Find the least number of perfect square numbers that sum to n.
        
            - type: n (int)
            -rtype: int
        '''
        # List all perfect squares <= n
        self.perfect_squares = set([x*x for x in range(1, int(n**0.5)+1)])
        
        # Case when n is already a perfect square number 
        if n in self.perfect_squares:
            return 1
        
        # Create a dp, where index = i and value = east number of 
        # perfect square numbers that sum to i.
        # If i is a perfect square, dp[i] = 1
        # Else, loop all dp[i]-x (x = a perfect square < i) and find
        # the smallest 1 + dp[i-x]
        dp = [10000]*(n+1)
        dp[1] = 1
        for i in range(2, n+1):
            if i in self.perfect_squares:
                dp[i] = 1
            else:
                for x in [p for p in self.perfect_squares if p < i]:
                    dp[i] = min(dp[i], 1 + dp[i-x])

        return dp[-1]




Day 197, 01/25/2021 Mon

Check If All 1's Are at Least Length K Places Away

class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        '''
        Check if all 1's are at least k places away from each other.
        
            -types: nums (List[int])
                       k (int)
            -rtype: bool
        '''
        # Loop nums. Every time when see a 1, record its position, pos.
        # When see next 1, check if its position i and pos < k.
        # If yes, return False. Else, assign i to pos and continue checking.
        pos = 0 if nums[0] else -1
        for i in range(1, len(nums)):
            if pos > -1 and nums[i] and i != pos and i - pos <= k: 
                return False
            
            if nums[i]:
                pos = i
                  
        return True
        
0015. 3Sum

0323. Number of Connected Components in an Undirected Graph

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        '''
        Find the number of connected components in an undirected graph.
            
            -types:     n (int)
                    edges (List[List[int]])
            -rtype: int
        '''
        # Create a dict, d, to record nodes and its conneted nodes , where key
        # = this node and value = a set of connected nodes
        d = {}
        for x, y in edges:
            if x in d:
                d[x].add(y)
            else:
                d[x] = set([y])
            
            if y in d:
                d[y].add(x)
            else:
                d[y] = set([x])

        # Create a set, visited, to record nodes visited
        visited = set()
        
        # Loop from 0 to n-1. Initiate final result = number of connected components, as res.
        # If i has been visited, then skip i and run i + 1
        # Talking about i has bot been visited:
        # 1). If i in d, put i in visited. Create a queue to hold all its connected nodes that
        #     are not visited. Keep adding unvisted connected nodes of nodes in the queue, until
        #     the queue is empty
        # 2). If i is not in d, then it means i is an isolated point, so res +1.
        res = 0
        
        for i in range(n):
            if i not in visited:
                if i in d:
                    queue = [i]
                    while queue:
                        currNode = queue.pop()
                        visited.add(currNode)
                        queue = list(d[currNode]) + queue
                        queue = [x for x in queue if x not in visited]
                res += 1

        return res



Day 198, 01/26/2021 Tue

Path With Minimum Effort




Day 199, 01/27/2021 Wed

Concatenation of Consecutive Binary Numbers

class Solution:
    def concatenatedBinary(self, n: int) -> int:
        '''
        Concatenating the binary representations of 1 to n in order and mod 10^9 + 7.
        
            - type: n (int)
            -rtype: int
        '''
        res = ''
        for x in range(1, n+1):
            res += bin(x)[2:]
        res = int(res, 2)%(10**9 + 7)
        return res



0152. Maximum Product Subarray

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        '''
        Find  the largest product of contiguous subarrays within nums.
        
            - type: nums (List[int])
            -rtype: int
        '''
        # Create two arrays, Max and Min, to record max and min 
        # cumulative product before current element (inclusive).
        # Initiate 1st ele for both as nums[0].
        Max = [None for _ in range(len(nums))]
        Min = [None for _ in range(len(nums))]
        Max[0] = [nums[0]]
        Min[0] = [nums[0]]
        
        # Loop nums for the 2nd ele.
        # Determine current Max and Min at position i based on product of
        # current ele with Max[i-1]/Min[-1] or nums[i] itself, since
        # max/min can change with sign or multiplying by 0.
        # The max of Max will then be the final result.
        for i in range(1, len(nums)):
            Max[i] = max(nums[i]*Max[i-1], nums[i]*Min[i-1], nums[i])
            Min[i] = min(nums[i]*Max[i-1], nums[i]*Min[i-1], nums[i])
        
        return max(Max)



0200. Number of Islands   

class Solution:  
    # Define a function, dfs, to search all connected cells in grid of 
    # current cell and mark them as visited.
    def dfs(self, x: int, y: int, h: int, w: int, grid: List[List[str]]) -> None:    
        '''
        Search all connected cells in grid for the cell at position (i, j) and mark
        them as visited. Height and width of grid are h and w

            -types:    x (int)
                       y (int)
                       h (int)
                       w (int)
                    grid (List[List[str]])
            -rtype: None
        '''
        if 0 <= x < h and 0 <= y < w and grid[x][y] == '1' and not self.visited[x][y]:
            self.visited[x][y] = 1
            self.dfs(x+1, y, h, w, grid)
            self.dfs(x, y+1, h, w, grid)
            self.dfs(x-1, y, h, w, grid)
            self.dfs(x, y-1, h, w, grid)

    def numIslands(self, grid: List[List[str]]) -> int:
        '''
        Find total number of island in grid.
        
            - type: grid (List[List[str]])
            -rtype: int
        '''
        h, w = len(grid), len(grid[0])
        # Create a array of arrays, vistied, with same size as grid
        # to record if a cell in grid is visited. Set each ele as 0 initially.
        self.visited = [[0 for _ in range(w)] for _ in range(h)]
        
        # Loop grid. Once a cell has value = 1, mark it as visited and visit all its   
        # neigbors, until none of them is 1 or all are visited.
        res = 0
        for i in range(h):
            for j in range(w):
                if grid[i][j] == '1' and self.visited[i][j] == 0:
                    res += 1
                    self.dfs(i, j, h, w, grid)
        return res



Day 200, 01/28/2021 Thu

Smallest String With A Given Numeric Value

class Solution:
    def getSmallestString(self, n: int, k: int) -> str:
        '''
        Find the lexicographically smallest string with length equal to n and numeric value equal to k.
        
            -types:   n (int)
                      k (int)
            -rtype: str
        '''
        # Initiate res.
        res = ''
        
        # Determine how many 'a' we can have. 
        while k - 1 <= (n-1) * 26:
            res += 'a'
            k -= 1
            n -= 1
        
        # For remaining k, determine min number of 'z' we need,
        # and then convert the remaining value to the letter
        # btw 'a's and 'z's
        res += chr(k - 26*(n-1) + 96) + (n-1)*'z'
        
        return res



0437. Path Sum III

1197. Minimum Knight Moves



Day 201, 01/29/2021 Fri

Number Of Corner Rectangles

Vertical Order Traversal of a Binary Tree

class Solution:
    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
        '''
        Find vertical order traversal of root.
        
            -type : root (TreeNode)
            -rtype: List[List[int]]
        '''
        # Case when root is empty
        if not root:
            return []
        
        # Assume coordinates of root is (0, 0).
        # Traverse the root, once go left, x-coordinate - 1;
        # once go right, x-coordinate + 1.
        # Onc go down 1 level, y-coordinate + 1.
        # Use a dict, d, with key = x-cor and val = another dict d0, to record nodes
        # traversed.
        # For d0, key = y-cor and value = a sorted list of values
        d = {}
        nodes_in_current_level = [[root, 0, 0]]
        
        while nodes_in_current_level:
            child_nodes = []
            while nodes_in_current_level:
                curr_node = nodes_in_current_level.pop()
                if curr_node[1] in d:
                    if curr_node[2] in d[curr_node[1]]:
                        d[curr_node[1]][curr_node[2]].append(curr_node[0].val)
                    else:
                        d[curr_node[1]][curr_node[2]] = [curr_node[0].val]
                else:
                    d[curr_node[1]] = {}
                    d[curr_node[1]][curr_node[2]] = [curr_node[0].val]
                
                if curr_node[0].left:
                    child_nodes.append([curr_node[0].left, curr_node[1] - 1, curr_node[2] + 1])
                if curr_node[0].right:
                    child_nodes.append([curr_node[0].right, curr_node[1] + 1, curr_node[2] + 1])
            nodes_in_current_level = child_nodes
        
        # Combine values under same x and y coordinates
        res = []
        for x in sorted(d):
            temp = []
            for y in sorted(d[x]):
                temp.extend(sorted(d[x][y])) 
            res.append(temp)

        return res



0543. Diameter of Binary Tree

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:



Day 202, 01/30/2021 Sat
Day 203, 01/31/2021 Sun

Day 204, 02/01/2021 Mon

Squirrel Simulation

class Solution:
    def minDistance(self, height: int, width: int, tree: List[int], squirrel: List[int], nuts: List[List[int]]) -> int:
        

0300. Longest Increasing Subsequence

0735. Asteroid Collision

class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        '''
        Find out the state of the asteroids after all collisions.
            
            - type: asteroids (List[int])
            -rtype: List[int]
        '''
        # Create result list, res
        # Loop asteroids. 
        # If res is empty or last ele in res has the same sign as current asteroid,
        # append current asteroid to res.
        # If the last ele in res > 0 (larger size) and current asteroid < 0 (smaller size),
        # smash current asteroid and move to next asteriod.
        # If the last ele in res > 0 (smaller size) and current asteroid < 0 (larger size),
        # smash last ele in res (note if res will be empty) and keep comparing the last ele in res.
        # If last ele in res > 0 and current asteroid < 0 and they have same size, 
        # move to next asteriod and pop last ele in res.
        # If last ele in res < 0 and current asteroid > 0, append current asteroid to res.
        res = []
        i, l = 0, len(asteroids)
        while i < l:
            if res:
                while i < l and res and (res[-1]*asteroids[i] > 0 or res[-1] < 0 and asteroids[i] > 0):
                    res.append(asteroids[i])
                    i += 1
                while i < l and res and res[-1] > 0 and asteroids[i] < 0 and abs(res[-1]) > abs(asteroids[i]):
                    i += 1
                while i < l and res and res[-1] > 0 and asteroids[i] < 0 and abs(res[-1]) < abs(asteroids[i]):
                    res.pop()
                while i < l and res and res[-1] > 0 and asteroids[i] < 0 and abs(res[-1]) == abs(asteroids[i]):
                    res.pop()
                    i += 1         
            else:
                res.append(asteroids[i])
                i += 1
 
        return res





Day 205, 02/02/2021 Tue

Day 206, 02/03/2021 Wed

0695. Max Area of Island

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        

1048. Longest String Chain

class Solution:
    def longestStrChain(self, words: List[str]) -> int:




Day 207, 02/04/2021 Thu
Day 208, 02/05/2021 Fri
Day 209, 02/06/2021 Sat
Day 210, 02/07/2021 Sun
Day 211, 02/08/2021 Mon
Day 212, 02/09/2021 Tue
Day 213, 02/10/2021 Wed
Day 214, 02/11/2021 Thu
Day 215, 02/12/2021 Fri
Day 216, 02/13/2021 Sat
Day 217, 02/14/2021 Sun
