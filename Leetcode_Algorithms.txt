Day 001, 07/13/2020 Mon
Day 002, 07/14/2020 Tue
Day 003, 07/15/2020 Wed
Day 004, 07/16/2020 Thu
Day 005, 07/17/2020 Fri
Day 006, 07/18/2020 Sat
Day 007, 07/19/2020 Sun
Day 008, 07/20/2020 Mon
Day 009, 07/21/2020 Tue
Day 010, 07/22/2020 Wed
Day 011, 07/23/2020 Thu
Day 012, 07/24/2020 Fri
Day 013, 07/25/2020 Sat
Day 014, 07/26/2020 Sun
Day 015, 07/27/2020 Mon
Day 016, 07/28/2020 Tue
Day 017, 07/29/2020 Wed
Day 018, 07/30/2020 Thu
Day 019, 07/31/2020 Fri
Day 020, 08/01/2020 Sat
Day 021, 08/02/2020 Sun
Day 022, 08/03/2020 Mon
Day 023, 08/04/2020 Tue
Day 024, 08/05/2020 Wed
Day 025, 08/06/2020 Thu
Day 026, 08/07/2020 Fri
Day 027, 08/08/2020 Sat
Day 028, 08/09/2020 Sun
Day 029, 08/10/2020 Mon
Day 030, 08/11/2020 Tue
Day 031, 08/12/2020 Wed
Day 032, 08/13/2020 Thu
Day 033, 08/14/2020 Fri
Day 034, 08/15/2020 Sat
Day 035, 08/16/2020 Sun

Day 036, 08/17/2020 Mon

1385. Find the Distance Value Between Two Arrays

class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        '''
        Find the distance between arr1 and arr2.
        
            types: arr1 (List[int])
                   arr2 (List[int])   
                      d (int)
            rtype: int
        '''
        return sum([not any([abs(x - y) <= d for y in arr2]) for x in arr1])



0748. Shortest Completing Word

class Solution:
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        '''
        Find the minimum length word from a given dictionary words, 
        which has all the letters from the string licensePlate.
        
            types: licensePlate (str) 
                          words (List[str])
            rtype: str
        '''
        # Filter out non-alphabetics chars in licensePlate,
        # and convert all chars to lower case.
        licensePlate = list(licensePlate)
        licensePlate = [x.lower() for x in licensePlate if x.isalpha()]
        licensePlate = ''.join(licensePlate)
        
        # Convert all letters in words to lower case
        words = [x.lower() for x in words]
        
        # Use counter to find the first word such that licensePlate is a subset of it.
        # If it is, then check if current word has smaller length and res. If yes, then 
        # assign this word to res. Otherwise, continue.
        res = 'a'*1000
        from collections import Counter
        plate_cnt = Counter(licensePlate)
        for word in words:
            cnt = Counter(word)
            if len(cnt - plate_cnt) >= 0 and len(plate_cnt - cnt) == 0:
                if len(word) < len(res):
                    res = word
        return res



0949. Largest Time for Given Digits

class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        '''
        Find the largest 24 hour time that can be made. 
        If no valid time can be made, return an empty string.
        
            type : A (List[int])
            rtype: str
        '''
        # Initiate result, res
        res = ''
        
        # Loop A. For each loop, find the largest legal hour, and 
        # check if min will also will be legal.
        current_h = current_m = -1
        for i in range(4):
            for j in range(4):
                # Create largest legal hour using two different ele
                if i != j and current_h <= 10*A[i] + A[j] < 24:
                    # Check if the other two eles and create legal min.
                    # If yes, find the largest one.
                    minute = [A[x] for x in range(4) if x not in [i, j]]
                    minute = [10 * minute[0] + minute[1], 10 * minute[1] + minute[0]]
                    minute = [x for x in minute if x < 60]
                    
                    if minute:
                        if 10*A[i] + A[j] == current_h and current_m < max(minute):
                                current_m = max(minute)
                        elif 10*A[i] + A[j] > current_h:
                                current_h = 10*A[i] + A[j]
                                current_m = max(minute)
                            
        if current_h == -1 and current_m == -1:
            return ''
        # Add leading zero if either of current_h or current_m is < 10
        current_h = '0' + str(current_h) if current_h < 10 else str(current_h)
        current_m = '0' + str(current_m) if current_m < 10 else str(current_m)
        
        return current_h  + ":" + current_m


Day 037, 08/18/2020 Tue



Day 038, 08/19/2020 Wed

1317. Convert Integer to the Sum of Two No-Zero Integers

class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        '''
        Convert n to the sum of two integers without 0
        
            -type : n (int)
            -rtype: List[int]
        '''
        # Loop n from 1 to n//2.
        # If neither of x or n-x contains 0, then return [x, n-x] 
        for x in range(1, n//2+1):
            if '0' not in str(x) and '0' not in str(n-x):
                return [x, n-x]



0257. Binary Tree Paths

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:



1078. Occurrences After Bigram

class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        '''
        Find all words after occurences of first and second word
        
            -type : text (str)
            -type : first (str)
            -type : second (str)
            -rtype: List[str]
        '''
        # Spilt text to a list
        text = text.split(' ')
        
        # Loop text and find such a pattern
        i = 0
        l = len(text) - 2
        res = []
        while i < l:
            if text[i] == first and text[i+1] == second:
                res.append(text[i+2])
            i += 1
        
        return res



Day 039, 08/20/2020 Thu

1507. Reformat Date

cclass Solution:
    def reformatDate(self, date: str) -> str:
        '''
        Refromat date to format YYYY-MM-DD
        
            -type : date (str)
            -rtype: str
        '''
        
        # Splite date by spaces
        date = date.split(' ')
        
        # Remove chars in day
        date[0] = [x for x in date[0] if x.isnumeric()]
        date[0] = ''.join(date[0]) if len(date[0]) == 2 else '0'+date[0][0]
        
        import calendar
        date[1] = str(list(calendar.month_abbr).index(date[1]))
        date[1] = '0'+date[1] if len(date[1]) == 1 else date[1]
        
        return date[2] + '-' + date[1] + '-' + date[0]



1486. XOR Operation in an Array

class Solution:
    def xorOperation(self, n: int, start: int) -> int:
        '''
        Create and find XOR of all elements of nums
            
            -type :     n (int)
                    start (int)
            -rtype: int
        '''
        # Create nums
        nums = [start + 2*i for i in range(n)] 
        
        # Return the bitwise XOR
        from functools import reduce
        return reduce(lambda x, y: x^y, nums)



0669. Trim a Binary Search Tree

class Solution:
    def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:
        


Day 040, 08/21/2020 Fri
Day 041, 08/22/2020 Sat
Day 042, 08/23/2020 Sun

Day 043, 08/24/2020 Mon

0160. Intersection of Two Linked Lists

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:



0763. Partition Labels

class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        '''
        Find size of each partiton part of S, where each letter appears in at most one part
        
            -type : S (str)
            -rtype: List[int]
        '''
        # Counter frequency of each letter
        from collections import Counter
        freq = Counter(S)
        
        # Convert S to list of chars
        S = list(S)
        
        # Initiate result as res
        res = []
        
        # Loop S (reversely).
        # Find partion points and record length of each partition.
        # Use a set to record all chars seen. If freq of this char is 0,
        # check if all othe chars in the set are also 0. 
        # If yes, partition poin found; else, continue.
        holder = set([])  # Remember uniqe chars from S
        cnt = 0           # Record length of current partition 
        while S:
            temp = S.pop() # Pop and record last char in S 
            freq[temp] -= 1
            holder.add(temp)
            cnt += 1
            if freq[temp] == 0:
                if sum([freq[x] for x in holder]) == 0: # Partiton point found
                    res.append(cnt)
                    # Reset holder and cnt #
                    holder = set([])
                    cnt = 0
        
        # Reverse res (since S is popped reversely)
        res.reverse()
        
        return res



Day 044, 08/25/2020 Tue



Day 045, 08/26/2020 Wed

0944. Delete Columns to Make Sorted

class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        '''
        Find the minimum possible length of D (delection set) s.t. 
        each remaining column in A is in non-decreasing sorted order
        
            -type : A (List[str])
            -rtype: int
        '''
        res = 0    # Initiate result, length of deletion set
        
        # Special case
        if len(A) == 1:
            return 0
            
        # Loop index i of each word in A.
        # If, for an index i, A[x-1][i] > A[x][i], incremnent res and start next index
        for i in range(len(A[0])):
            for x in range(1, len(A)):
                if A[x-1][i] > A[x][i]:
                    res += 1
                    break
        return res



1431. Kids With the Greatest Number of Candies

class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        '''
        Find if every kid in candies can have the greatest number of candies with extraCandies
        
            -type :      candies (List[int])
                    extraCandies (int)
            -rtype: List[bool]  
        '''
        # Find max of candies
        m = max(candies)
        
        # Loop candies.
        # Determine if ith candy + extraCandies >= m
        return [c+extraCandies >= m for c in candies]

        
        
0131. Palindrome Partitioning

class Solution:
    def partition(self, s: str) -> List[List[str]]:
        '''
        Partition s such that every substring of the partition is a palindrome
        
            -type : s (str)
            -rtype: List[List[str]]
        '''
        if len(s) == 1:
            return [[s]]
        else:
            res = []
            i = 0
            while i < len(s)-1:
                if self.isPalindrome(s[:(i+1)]):
                    res.extend([[s[:(i+1)]] + x for x in self.partition(s[(i+1):])])
                i += 1
            if self.isPalindrome(s):
                res.append([s])
            return res

    def isPalindrome(self, s: str) -> bool:
        '''
        Determine if s is palindrome
        
            -type : s (str)
            -rtype: bool  
        '''
        # If empty, yes
        if not s:
            return False
        
        # Loop s from both ends and check
        i, j = 0, len(s) - 1
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True



Day 046, 08/27/2020 Thu
Day 047, 08/28/2020 Fri
Day 048, 08/29/2020 Sat
Day 049, 08/30/2020 Sun



Day 050, 08/31/2020 Mon

0938. Range Sum of BST

class Solution:
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
        '''
        Find the sum of node values between L and R, inclusive
            
            -type : root (TreeNode)
                       L (int)
                       R (int)
            -rtype: int
        '''
        # Check if root is NULL:
        if not root:
            return 0
        
        # If no child
        if not (root.left or root.right):
            return root.val if L <= root.val <= R else 0 
        
        # Check both left and right child
        if root.left and root.right:
            # Case when root value > R, then just search left child 
            if root.val > R:
                return self.rangeSumBST(root.left, L, R)
            # Case when root value < L, then just search right child 
            elif root.val < L:
                return self.rangeSumBST(root.right, L, R)
            # Otherwise, search both
            else:
                return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)
                
        # If only one child exists and root value in [L, R]
        if root.left and root.val >= L:
            return root.val + self.rangeSumBST(root.left, L, R)
        if root.right and root.val <= R:
            return root.val + self.rangeSumBST(root.right, L, R)
        else:
            return 0



1480. Running Sum of 1d Array

class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        '''
        Find the running sum of nums
        
            -type : nums (List[int])
            -rtype: List[int]
        '''
        res = nums[:]
        for i in range(1, len(res)):
            res[i] += res[i-1]
        return res



0017. Letter Combinations of a Phone Number

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        '''
        Find all possible word combinations of numbers in digits
        
            -type : digits (str)
            -rtype: List[str]        
        '''
        # Check if digits is empty
        if not digits:
            return []
        
        # Create a dictionary, d, to map int: char relationship 
        # in phon buttons
        import string
        d = {str(i):string.ascii_lowercase[(3*(i-2)):3*(i-2)+3] for i in range(2, 7)}
        d['7'] = 'pqrs'
        d['8'] = 'tuv'
        d['9'] = 'wxyz'
        
        # Use itertools to find all combinations, and reuse d as result
        from itertools import product
        from functools import reduce
        d = reduce(lambda x, y: product([''.join(ele) for ele in x], y), [list(d[i]) for i in digits])
        
        return [''.join(x) for x in d]
        
        

Day 051, 09/01/2020 Tue
Day 052, 09/02/2020 Wed

Day 053, 09/03/2020 Thu

0893. Groups of Special-Equivalent Strings

class Solution:
    def numSpecialEquivGroups(self, A: List[str]) -> int:
        '''
        Find the number of groups of special-equivalent strings from A
        
            -type : A (List[str]) 
            -rtype: int
        '''
        # Convert all str in A to their equivalent str
        A = [self.equivalentString(s) for s in A]

        return len(set(A))
        
        
    def equivalentString(self, s: str) -> str:
        '''
        Convert s to its equivalent string, where chars in odd/even
        indices are in alphabetic orders
        
            -type : s (str)
            -rtype: str
        '''
        # Convert s to a list
        s = list(s)
        
        # Reorder s as sorted odd indexed eles + sorted even indexed eles
        s = sorted([x[1] for x in enumerate(s) if x[0]%2]) + sorted([x[1] for x in enumerate(s) if x[0]%2 == 0])
      
        return ''.join(s)
             
        
        
1413. Minimum Value to Get Positive Step by Step Sum

class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        '''
        Find the minimum positive value of startValue such that the step by step sum is never less than 1
        
            -type : nums (List[int])
            -rtype: int
        '''
        # Find the min step by step sum of nums
        minSum = currSum = nums[0]
        for i in range(1, len(nums)):
            currSum += nums[i]
            minSum = min(minSum, currSum)
        # Return max of 1 and 1 - minSum as min startValue
        return max(1, 1 - minSum)

        
        
0054. Spiral Matrix

class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        



Day 054, 09/04/2020 Fri
Day 055, 09/05/2020 Sat
Day 056, 09/06/2020 Sun

Day 057, 09/07/2020 Mon
Day 058, 09/08/2020 Tue
Day 059, 09/09/2020 Wed
Day 060, 09/10/2020 Thu
Day 061, 09/11/2020 Fri
Day 062, 09/12/2020 Sat
Day 063, 09/13/2020 Sun

