Day 001, 06/07/2021 Mon

Min Cost Climbing Stairs

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        '''
        Find the minimum cost to reach the top of the floor.
        
          -type : cost (List[int])
          -rtype: int
        '''
        l = len(cost)        # Heigh of the floor
        costed = [0] * (l+1) # Initiate an array. This array is to 
                             # record min cost of climbing to each
                             # step
        cost.append(0)       # Cost at the top is 0
        
        for i in range(2, l+1):
            costed[i] = min(costed[i-1] + cost[i-1], costed[i-2] + cost[i-2]) 
        
        return costed[-1]



Paint House

class Solution:
    def minCost(self, costs: List[List[int]]) -> int:
        '''
        Find the minimum cost to paint all houses with no adjacent houses have the same color.
        
          -type : costs (List[List[int]])
          -rtype: int
        '''
        # Create an array with ele = cost of painting [color1, color2, color3], and length of
        # the array = length of costs
        res = [[0, 0, 0] for _ in range(len(costs))]
        res[0] = costs[0]
        
        # Loop costs from start to end and find min costs at each position
        for i in range(1, len(costs)):
            res[i][0] = costs[i][0] + min(res[i-1][1], res[i-1][2])
            res[i][1] = costs[i][1] + min(res[i-1][2], res[i-1][0])
            res[i][2] = costs[i][2] + min(res[i-1][0], res[i-1][1])
        return min(res[-1])

0740. Delete and Earn



Day 002, 06/08/2021 Tue

0490. The Maze

0593. Valid Square



Day 003, 06/09/2021 Wed

0055. Jump Game

0241. Different Ways to Add Parentheses

0316. Remove Duplicate Letters


Day 004, 06/10/2021 Thu

My Calendar I

0739. Daily Temperatures

1405. Longest Happy String



Day 005, 06/11/2021 Fri

Day 006, 06/12/2021 Sat

0390. Elimination Game


Day 007, 06/13/2021 Sun

Day 008, 06/14/2021 Mon

Maximum Units on a Truck

class Solution:
    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:
        '''
        Find the maximum total number of units that can be put on the truck.
        
            -types:  boxTypes (List[List[int]])
                    truckSize (int)
            -rtype: int
        '''
        # Sort boxTypes based on number of units.
        boxTypes.sort(key = lambda x: x[1])
        
        # Put boxTypes eles from the very end t the truck, until the truck
        # reaches its max capacity
        res = [0, 0]  # First ele = total # of boxes, and second ele = total # of units
        while boxTypes and res[0] + boxTypes[-1][0] <= truckSize:
            res[0] += boxTypes[-1][0]
            res[1] += boxTypes[-1][0]*boxTypes[-1][1]
            boxTypes.pop()
        
        # Check if the truck ca load more boxes
        if boxTypes:
            res[1] += (truckSize - res[0])*boxTypes[-1][1]
            res[0] += truckSize - res[0]
        
        return res[1]

The Maze II



Day 009, 06/15/2021 Tue

Matchsticks to Square

1717. Maximum Score From Removing Substrings


Day 010, 06/16/2021 Wed

Generate Parentheses

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        '''
        Generate all combinations of n pairs of well-formed parentheses.
        
        :type : n (int)
        :rtype: List[str]
        '''

        d = {0: [''],
             1: ['()']}
             
        import itertools
        
        # Iteratively create well-formed parentheses combos from 2 to n
        for i in range(2, n+1):
            res = []
            for j in range(1, i):
                temp = ['('+x[0]+')' + x[1] for x in itertools.product(d[j], d[i-1-j])]
                res.extend(temp)
                temp = [x[0] + '('+x[1]+')' for x in itertools.product(d[j], d[i-1-j])]
                res.extend(temp)
            d[i] = list(set(res))
        return d[n]



Shortest Distance to Target Color




Day 011, 06/17/2021 Thu

Number of Subarrays with Bounded Maximum

1718. Construct the Lexicographically Largest Valid Sequence



Day 012, 06/18/2021 Fri



Day 013, 06/19/2021 Sat

1291. Sequential Digits

class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        '''
        Find the sorted list of all the integers in the range [low, high] inclusive that have sequential digits. 

        -types:  low (int) 
                high (int)
        -rtype: List[int]
        '''
        import math
        
        # Find the smallest integer with sequential digits >= low
        power = int(math.log(low, 10)) 
        start = int('123456789'[-power:])
        while start < low and start < 123456789:
            if start < int('123456789'[-power:]):
                start += int('1'*power)
            else:
                start = int('123456789'[:power+1])
                power += 1
        
        # Find the largest integer with sequential digits <= high
        power = int(math.log(high, 10)) 
        end = int('123456789'[-power-1:])
        while end > high and end > 12:
            if end > int('123456789'[:power+1]):
                end -= int('1'*(power+1))
            else:
                end = int('123456789'[-power:])
                power -= 1
        
        print(start, end)
        # Generate all integers with sequential digits in [start, end]
        res = [start] if start <= end and start >= low and end <= high else []
        while res and res[-1] < end:
            power = int(math.log(res[-1], 10)) 
            if res[-1] < int('123456789'[-power-1:]):
                res.append(res[-1] + int('1'*(power+1)))
                
            else:
                power += 1
                res.append(int('123456789'[:power+1]))
            
        return res
            

        

Day 014, 06/20/2021 Sun

1721. Swapping Nodes in a Linked List


1722. Minimize Hamming Distance After Swap Operations




Day 015, 06/21/2021 Mon

1733. Minimum Number of People to Teach


Day 016, 06/22/2021 Tue

1167. Minimum Cost to Connect Sticks

class Solution:
    def connectSticks(self, sticks: List[int]) -> int:
        '''
        Find the minimum cost of connecting all the given sticks into one stick.
        
        :type - sticks: List[int]
        :rtype- int
        '''
        import heapq
        sticks.sort()
        cost = 0
        
        # Use heap to find the 2 smallest stick and combine them.
        # Then put the combined back to sticks
        # Repeat the process until the is only 1 stick left.
        while True:
            sticks_out = heapq.heappop(sticks)
            
            # Check if sticks is now empty.
            # If yes, then just return cost
            if not sticks: return cost
            
            sticks_out += heapq.heappop(sticks)
            cost += sticks_out
            heapq.heappush(sticks, sticks_out)



Number of Matching Subsequences



All Paths from Source Lead to Destination

class Solution:
    def leadsToDestination(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:








Day 017, 06/23/2021 Wed

Reverse Linked List II

class Solution:
    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:
        '''
        Reverse the nodes of the list from position left to position right, and return the reversed list.
        
        :types -  head: ListNode
                  left: int
                 right: int
        :rtype - ListNode
        '''        
        curr_pos = 1
        
        # Create a new ListNode and move it to the node with position = left
        t = head
        while t and curr_pos < left:
            t = t.next
            curr_pos += 1 
        mid = None  # Part to reverse
        
        # Reverse the part btw left and right, inclusively
        while curr_pos <= right:
            temp = t
            t = t.next
            temp.next = mid
            mid = temp
            curr_pos += 1
        
        # Combine part not reversed, part reversed, and tail
        p = head
        p_pos = 1
        if left == 1:
            head = mid
        else:
            while p_pos + 1 < left:
                p = p.next
                p_pos += 1
            p.next = mid

        while p and p.next:
            p = p.next
        p.next = t
            
        return head



0139. Word Break



Day 018, 06/24/2021 Thu

Out of Boundary Paths

class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        '''
        Find the number of paths to move the ball out of the grid boundary.
        
            -types:           m (int)
                              n (int) 
                        maxMove (int) 
                       startRow (int)
                    startColumn (int)
            -rtype: int
        '''
        # Initiate a variable to record the number of paths
        self.res = 0
        # Initiate a variable to record if a grid has been visited
        self.visited = set()
        
        # Define a function to move the ball to next grids (left, right, top, or bottom). Determine if
        # current position is out of grid  and maxMove >= 0, then increment self.res.
        def ifOOB(m: int, n: int, moves_remaining: int, currRow: int, currColumn: int) -> None:
            '''
            Determine if adjacent cells are out of boundry and number of remaining moves is still > 0.

                -types:               m (int)
                                      n (int) 
                        moves_remaining (int) 
                               currtRow (int)
                             currColumn (int)
                -rtype: None
            '''
            # Case when current position is out of boundry, then return True
            if currRow == -1 or currRow == m or currColumn == -1 or currColumn == n:
                self.res += 1
            
            # Case when no extra move is available
            elif moves_remaining == 0: return
            
            # Move to all four adjacent cells
            else:
                for dx, dy in [[1, 0], [-1, 0], [0, 1], [0, -1]]:
                    ifOOB(m, n, moves_remaining - 1, currRow + dx, currColumn + dy)
        
        ifOOB(m, n, maxMove, startRow, startColumn)
        return self.res % (10 ** 9 + 7)
        


1091. Shortest Path in Binary Matrix

class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        '''
        Find the length of the shortest clear path in grid.
        
            -type : grid (List[List[int]])
            -rtype: int
        '''
        # Case when the top-left cell or the bottom-right is 1, then just -1
        if grid[0][0] or grid[-1][-1]: return -1
        
        # Define some variables
        n = len(grid) # Length of each side of grid
        
        # A n*n matrix to record min steps of a clear path from the top-left cell to current position
        self.steps = [[n*n for _ in range(n)] for _ in range(n)]
        self.steps[0][0] = 1
        
        # Define a function to update min steps of clear path from the top-left to current position
        def minSteps(x:int, y:int, n: int, grid: List[List[int]]) -> None:
            '''
            Update min steps of clear path from top-left to current position
            
                -types:    x (int)
                           y (int)
                           n (int)
                        grid (List[List[int]])
                -rtype: None
            '''
            for dx, dy in [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < n and 0 <= new_y < n and grid[new_x][new_y] == 0:
                    self.steps[x][y] = min(self.steps[x][y], self.steps[new_x][new_y]+1)
        
        # Loop grid, find the min steps of the bottom-right cell
        for i in range(n):
            for j in range(n):
                minSteps(i, j, n, grid)
        return self.steps[-1][-1] if self.steps[-1][-1] <= n*n else -1
                    





1120. Maximum Average Subtree

class Solution:
    # Define a function to find the number of nodes, and sum of all nodes values, and the max average seen so far
    def sumAndCount(self, root: TreeNode) -> List[List]:
        '''
        Find the number of nodes, and sum of all nodes values, and the max average seen so far

            -type : root (TreeNode)
            -rtype: List[List]
        '''
        # Case when root is null
        if not root: return [0, 0.0, 0.0]

        # Case when only left subtree exists
        elif not root.right: 
            temp = self.sumAndCount(root.left)
            return [1 + temp[0], 1.0*root.val + temp[1], max(temp[2], (1.0*root.val + temp[1])/(1 + temp[0]))]

        # Case when only right subtree exists
        elif not root.left: 
            temp = self.sumAndCount(root.right)
            return [1 + temp[0], 1.0*root.val + temp[1], max(temp[2], (1.0*root.val + temp[1])/(1 + temp[0]))]

        # Case when both left and right subtrees exist
        else:
            t1 = self.sumAndCount(root.right)
            t2 = self.sumAndCount(root.left)
            return [1+t1[0]+t2[0], 1.0*(root.val+t1[1]+t2[1]), max(1.0*(root.val+t1[1]+t2[1])/(1+t1[0]+t2[0]), t1[2], t2[2])]
            
    
    
    def maximumAverageSubtree(self, root: TreeNode) -> float:
        '''
        Find the maximum average value of any subtree of the tree.
        
            -type : root (TreeNode)
            -rtype: float
        '''
        return self.sumAndCount(root)[2]
        
        


Day 019, 06/25/2021 Fri

Redundant Connection



Day 020, 06/26/2021 Sat



Day 021, 06/27/2021 Sun

0207. Course Schedule



1552. Magnetic Force Between Two Balls



Day 022, 06/28/2021 Mon



Day 023, 06/29/2021 Tue

Max Consecutive Ones III

class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        '''
        Find the maximum number of consecutive 1's in nums with flipping at most k 0's.
        
            -types: nums (List[int]) 
                       k (int)
            -rtype: int
        '''
        # Use a sliding window to find the range with most consecutive 1's that with flipping at most k 0's
        start = 0         # Start position of the sliding window
        max_l = 0         # Maximum numbers of consecutive 1's with flipping at most k 0's
        zero_counter = 0  # Count occurence of 0's in current sliding window
        
        for i in range(len(nums)):
            if nums[i] == 0:
                # Shrink the window from left to keep 0_counter < 0
                while zero_counter == k:
                    zero_counter -= nums[start] == 0
                    start += 1
                zero_counter += 1
            max_l = max(max_l, i - start + 1)
        
        return max_l
            
                
                
                    
                    
            
            
        
        




1737. Change Minimum Characters to Satisfy One of Three Conditions

class Solution:
    def minCharacters(self, a: str, b: str) -> int:
 





Day 024, 06/30/2021 Wed
Day 025, 07/01/2021 Thu
Day 026, 07/02/2021 Fri
Day 027, 07/03/2021 Sat
Day 028, 07/04/2021 Sun
Day 029, 07/05/2021 Mon
Day 030, 07/06/2021 Tue
Day 031, 07/07/2021 Wed
Day 032, 07/08/2021 Thu
Day 033, 07/09/2021 Fri
Day 034, 07/10/2021 Sat
Day 035, 07/11/2021 Sun
Day 036, 07/12/2021 Mon
Day 037, 07/13/2021 Tue
Day 038, 07/14/2021 Wed
Day 039, 07/15/2021 Thu
Day 040, 07/16/2021 Fri
Day 041, 07/17/2021 Sat
Day 042, 07/18/2021 Sun
